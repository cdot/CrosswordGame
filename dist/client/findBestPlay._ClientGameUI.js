"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(window["webpackChunk_cdot_xanado"] = window["webpackChunk_cdot_xanado"] || []).push([["findBestPlay"],{

/***/ "./src/game/findBestPlay.js":
/*!**********************************!*\
  !*** ./src/game/findBestPlay.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"findBestPlay\": () => (/* binding */ findBestPlay)\n/* harmony export */ });\n/* harmony import */ var _loadDictionary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loadDictionary.js */ \"./src/game/loadDictionary.js\");\n/* harmony import */ var _Edition_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Edition.js */ \"./src/game/Edition.js\");\n/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Tile.js */ \"./src/game/Tile.js\");\n/* harmony import */ var _Move_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Move.js */ \"./src/game/Move.js\");\n/*Copyright (C) 2019-2022 The Xanado Project https://github.com/cdot/Xanado\n  License MIT. See README.md at the root of this distribution for full copyright\n  and license information. Author Crawford Currie http://c-dot.co.uk*/\n\n/* global assert */\n\n\n\n\n\n\n/** @module */\n\n/**\n * Return a list of the letters that are in both arrays. Does\n * not handle blank!\n * @param {string[]} a array of letters\n * @param {string[]} b array of letters\n * @return {string[]} intersection of a and b\n * @private\n */\nfunction intersection(a, b) {\n  return a.filter(l => b.indexOf(l) >= 0);\n}\n\n/**\n * Dictionary being used to find words\n * @private\n */\nlet dictionary;\n\n/**\n * Edition being played.\n * @private\n */\nlet edition;\n\n/**\n * A matrix where each [col][row] square has two lists, one of\n * valid vertical chars and another of valid horizontal chars. The\n * [0] lists give the letters that are valid for forming a\n * vertical cross word, and the [1] lists give the letters valid\n * for creating a horizontal cross word.\n * @private\n */\nlet crossChecks;\n\n/**\n * Shortcut to the board in the game\n * @private\n */\nlet board;\n\n/**\n * The listener function. This takes either a play, or a string\n * describing progress. This allows the finder to run in a thread\n * and still report back via the main event loop.\n * @private\n */\nlet report;\n\n/**\n * Best score found so far when searching for a move.\n * @private\n*/\nlet bestScore = 0;\n\n/**\n * Unlike Appel and Jacobsen, who anchor plays on empty squares,\n * we anchor plays on a square with a tile that has an adjacent\n * (horizontal or vertical) non-empty square. This significantly\n * reduces the number of anchors that have to be evaluated.\n * @param {number} col the square to inspect\n * @param {number} row the square to inspect\n * @return {boolean} true if this square is a valid anchor\n * @private\n */\nfunction isAnchor(col, row) {\n  return !board.at(col, row).isEmpty()\n  && (col > 0 && board.at(col - 1, row).isEmpty()\n      || col < board.cols - 1 && board.at(col + 1, row).isEmpty()\n      || row > 0 && board.at(col, row - 1).isEmpty()\n      || row < board.rows - 1 && board.at(col, row + 1).isEmpty());\n}\n\n/**\n * Determine which letters can fit in each square and form a valid\n * horizontal or vertical cross word. This returns a matrix where\n * each [col][row] square has two lists, one of valid vertical\n * chars and another of valid horizontal chars. The [0] lists give\n * the letters that are valid for forming a vertical cross word,\n * and the [1] lists give the letters valid for creating a\n * horizontal cross word.  The indices are chosen such that the\n * cells can be indexed using the dcol parameter in the other\n * functions.\n * @param {string[]} available the set of available letters\n * @private\n */\nfunction computeCrossChecks(available) {\n  const xChecks = [];\n\n  for (let col = 0; col < board.cols; col++) {\n    const thisCol = [];\n    xChecks.push(thisCol);\n\n    for (let row = 0; row < board.rows; row++) {\n      const thisCell = [[], []];\n      thisCol[row] = thisCell;\n\n      if (board.at(col, row).tile) {\n        // The cell isn't empty, only this letter is valid.\n        thisCell[0].push(board.at(col, row).tile.letter);\n        thisCell[1].push(board.at(col, row).tile.letter);\n        continue;\n      }\n\n      // Find the words above and below\n      let wordAbove = \"\";\n      let r = row - 1;\n      while (r >= 0 && board.at(col, r).tile) {\n        wordAbove = board.at(col, r).tile.letter + wordAbove;\n        r--;\n      }\n\n      let wordBelow = \"\";\n      r = row + 1;\n      while (r < board.rows && board.at(col, r).tile) {\n        wordBelow += board.at(col, r).tile.letter;\n        r++;\n      }\n\n      // Find the words left and right\n      let wordLeft = \"\";\n      let c = col - 1;\n      while (c >= 0 && board.at(c, row).tile) {\n        wordLeft = board.at(c, row).tile.letter + wordLeft;\n        c--;\n      }\n\n      let wordRight = \"\";\n      c = col + 1;\n      while (c != board.cols && board.at(c, row).tile) {\n        wordRight += board.at(c, row).tile.letter;\n        c++;\n      }\n\n      // Find which (if any) letters form a valid cross word\n      for (let letter of available) {\n        const h = wordLeft + letter + wordRight;\n\n        // Is h a complete valid word, or just the letter\n        // on its tod?\n        const hIsWord = h.length === 1 || dictionary.hasWord(h);\n        // Is h a valid complete word, or a legal sub-sequence?\n        const hIsSeq = hIsWord || col > 0 && dictionary.hasSequence(h);\n\n        const v = wordAbove + letter + wordBelow;\n        const vIsWord = v.length === 1 || dictionary.hasWord(v);\n        const vIsSeq = vIsWord || row > 0 && dictionary.hasSequence(v);\n\n        if (hIsWord && vIsSeq)\n          // A down word is playable with this letter, and\n          // there's a valid down sequence involving the\n          // letter\n          thisCell[0].push(letter);\n\n        if (vIsWord && hIsSeq)\n          // An across word is playable with this letter, and\n          // there's a valid across sequence involving the\n          // letter\n          thisCell[1].push(letter);\n      }\n    }\n  }\n\n  crossChecks = xChecks;\n}\n\n/**\n * Given a position that can have a letter, recursively compute possible\n * word plays by extending down/across the board. For each word,\n * compute its point value, and update the best score\n * accordingly.\n *\n * @param {number} col index of the current position on the board. This\n * is the posiiton of the last character of the word constructed so far.\n * @param {number} row index of the current position on the board. This\n * is the posiiton of the last character of the word constructed so far.\n * @param {number} dcol 1 if the extension direction is across\n * @param {number} drow 1 if the extension direction is down\n * @param {Tile[]} rackTiles tiles remaining from the user's letter rack.\n * @param {number} tilesPlayed number of tiles from the rack already played\n * @param {LetterNode} dNode the current LetterNode\n * @param {Tile[]} wordSoFar the known letters terminating at the dNode.\n * @private\n */\nfunction forward(col, row,\n                 dcol, drow,\n                 rackTiles, tilesPlayed,\n                 dNode,\n                 wordSoFar) {\n\n  // Square we're hopefully extending into\n  const ecol = col + dcol;\n  const erow = row + drow;\n\n  //console.log(`forward '${wordSoFar}' ${col}:${dcol} ${row}:${drow} [${dNode.postLetters.join('')}]`);\n\n  // Tail recurse; report words as soon as we find them\n  // Are we sitting at the end of a scoring word?\n  if (dNode.isEndOfWord\n      && wordSoFar.length >= 2\n      && tilesPlayed > 0\n      && (ecol == board.cols || erow == board.rows\n          || !board.at(ecol, erow).tile)) {\n    const words = [];\n    const score =\n          board.scorePlay(col, row, dcol, drow,\n                               wordSoFar, words)\n          + edition.calculateBonus(tilesPlayed);\n\n    if (score > bestScore) {\n      bestScore = score;\n      //console.log(drow > 0 ? \"vertical\" : \"horizontal\")\n      report(new _Move_js__WEBPACK_IMPORTED_MODULE_3__.Move({\n        placements: wordSoFar.filter(\n          t => !board.at(t.col, t.row).tile),\n        words: words,\n        score: score\n      }));\n    }\n  }\n\n  let available; // list of letters that can be extended with\n  let playedTile = 0;\n\n  if (ecol < board.cols && erow < board.rows) {\n    // Do we have an empty cell we can extend into?\n    if (board.at(ecol, erow).isEmpty()) {\n      const haveBlank = rackTiles.find(l => l.isBlank);\n      const xc = crossChecks[ecol][erow][dcol];\n\n      available = intersection(\n        dNode.postLetters,\n        haveBlank ? xc : intersection(\n          rackTiles.map(t => t.letter), xc));\n      playedTile = 1;\n\n    } else\n      // Have pre-placed tile\n      available = [ board.at(ecol, erow).tile.letter ];\n  }\n  else // off the board\n    available = [];\n\n  for (let letter of available) {\n    let shrunkRack = rackTiles;\n    if (playedTile > 0) {\n      // Letter played from the rack\n      const rackTile = shrunkRack.find(l => l.letter === letter)\n            || shrunkRack.find(l => l.isBlank);\n      wordSoFar.push(\n        new _Tile_js__WEBPACK_IMPORTED_MODULE_2__.Tile({letter:letter, isBlank:rackTile.isBlank,\n                  score:rackTile.score,\n                  // Note placement is not used in score computation\n                  col: ecol, row: erow}));\n      shrunkRack = shrunkRack.filter(t => t !== rackTile);\n    } else\n      wordSoFar.push(board.at(ecol, erow).tile);\n\n    for (let post of dNode.postNodes) {\n      if (post.letter === letter) {\n        forward(ecol, erow,\n                     dcol, drow,\n                     shrunkRack, tilesPlayed + playedTile,\n                     post,\n                     wordSoFar);\n      }\n    }\n\n    wordSoFar.pop();\n  }\n}\n\n/**\n * Given a position that may be part of a word, and the letters of\n * the word it may be part of, try to back up/left before extending\n * down/right.\n *\n * @param {number} col index of the current position on the board. This\n * is the posiiton of the last character of the word constructed so far.\n * @param {number} row index of the current position on the board. This\n * is the posiiton of the last character of the word constructed so far.\n * @param {number} dcol 1 if the extension direction is across\n * @param {number} drow 1 if the extension direction is down\n * @param {Tile[]} rackTiles tiles remaining from the user's letter rack.\n * @param {number} tilesPlayed number of tiles from the rack already played\n * @param {LetterNode} anchorNode the DictNode where we started backing up\n * @param {LetterNode} dNode the current LetterNode\n * @param {Tile[]} wordSoFar the known letters terminating at the dNode.\n * @private\n */\nfunction back(col, row,\n              dcol, drow,\n              rackTiles, tilesPlayed,\n              anchorNode, dNode,\n              wordSoFar) {\n\n  // Square we're hopefully extending into\n  const ecol = col - dcol;\n  const erow = row - drow;\n\n  let available; // the set of possible candidate letters\n  let playedTile = 0;\n\n  //console.log(`back '${wordSoFar}' ${col}:${dcol} ${row}:${drow} [${dNode.preLetters.join('')}]`);\n\n  // Do we have an adjacent empty cell we can back up into?\n  if (ecol >= 0 && erow >= 0) {\n    if (board.at(ecol, erow).isEmpty()) {\n      // Find common letters between the rack, cross checks, and\n      // dNode pre.\n      const haveBlank = rackTiles.find(l => l.isBlank);\n      const xc = crossChecks[ecol][erow][dcol];\n\n      available =\n      intersection(\n        dNode.preLetters,\n        haveBlank ? xc : intersection(\n          rackTiles.map(l => l.letter),  xc));\n      playedTile = 1;\n    } else\n      // Non-empty square, might be able to walk back through it\n      available = [ board.at(ecol, erow).tile.letter ];\n  }\n  else\n    // Off the board, nothing available for backing up\n    available = [];\n\n  // Head recurse; longer words are more likely to\n  // be high scoring, so want to find them first\n  for (let letter of available) {\n    let shrunkRack = rackTiles;\n    if (playedTile > 0) {\n      // Letter came from the rack\n      const tile = shrunkRack.find(l => l.letter === letter)\n            || shrunkRack.find(l => l.isBlank);\n      wordSoFar.unshift(\n        new _Tile_js__WEBPACK_IMPORTED_MODULE_2__.Tile({\n          letter: letter, isBlank: tile.isBlank,\n          score: tile.score,\n          // Note placement is not used in score computation\n          col: ecol, row: erow\n        }));\n      shrunkRack = shrunkRack.filter(t => t !== tile);\n    } else\n      // Letter already on the board\n      wordSoFar.unshift(board.at(ecol, erow).tile);\n\n    for (let pre of dNode.preNodes) {\n      if (pre.letter === letter) {\n        back(ecol, erow,\n                  dcol, drow,\n                  shrunkRack, tilesPlayed + playedTile,\n                  anchorNode, pre,\n                  wordSoFar);\n      }\n    }\n\n    wordSoFar.shift();\n  }\n\n  // If this is the start of a word in the dictionary, and\n  // we're at the edge of the board or the prior cell is\n  // empty, then we have a valid word start.\n  if (dNode.preNodes.length == 0\n      && (erow < 0 || ecol < 0 || board.at(ecol, erow).isEmpty())) {\n    //console.log(`back word start ${ecol}:${dcol},${erow}:${drow}`);\n    // try extending down beyond the anchor, with the letters\n    // that we have determined comprise a valid rooted sequence.\n    forward(col + dcol * (wordSoFar.length - 1),\n                 row + drow * (wordSoFar.length - 1),\n                 dcol, drow,\n                 rackTiles, tilesPlayed,\n                 anchorNode,\n                 wordSoFar);\n  }\n}\n\n/**\n * Special case of the opening move. Find anagrams of the player's\n * rack, and find the highest scoring position for each possible word.\n * @param {Tile[]} rackTiles tiles on the rack\n * @private\n */\nfunction bestOpeningPlay(rackTiles) {\n  const ruck = rackTiles.map(l => l.letter ? l.letter : \" \").join(\"\");\n  const choices = dictionary.findAnagrams(ruck);\n  //console.debug(\"Choices\", choices);\n  // Random whether it is played across or down\n  const drow = Math.round(Math.random());\n  const dcol = (drow + 1) % 2;\n  const vertical = dcol === 0;\n  bestScore = 0;\n\n  for (const choice in choices) {\n    // Keep track of the rack and played letters\n    const placements = [];\n    let shrunkRack = rackTiles;\n    for (const c of choice.split(\"\")) {\n      const rackTile = shrunkRack.find(t => t.letter === c)\n            || shrunkRack.find(t => t.isBlank);\n      /* c8 ignore next */\n      assert(rackTile,\n             \"Can't do this with the available tiles\");\n      placements.push(new _Tile_js__WEBPACK_IMPORTED_MODULE_2__.Tile({\n        letter: c, isBlank: rackTile.isBlank,\n        score:rackTile.score\n        // Placement is fixed later\n      }));\n      shrunkRack = shrunkRack.filter(t => t !== rackTile);\n    }\n\n    // Slide the word over the middle to find the optimum\n    // position\n    const mid = vertical ? board.midcol : board.midrow;\n    for (let end = mid;\n         end < mid + choice.length;\n         end++) {\n\n      const col = vertical ? mid : end;\n      const row = vertical ? end : mid;\n      const score =\n            board.scorePlay(col, row, dcol, drow, placements)\n            + edition.calculateBonus(placements.length);\n\n      if (score > bestScore) {\n        //console.debug(\"Accepted\",choice,\"at\",end,\"for\",score);\n        bestScore = score;\n        // Fix the placement\n        for (let i = 0; i < placements.length; i++) {\n          const pos = end - placements.length + i + 1;\n          placements[i].col = dcol == 0 ? board.midcol : pos * dcol;\n          placements[i].row = drow == 0 ? board.midrow : pos * drow;\n        }\n        //console.log(drow > 0 ? \"vertical\" : \"horizontal\")\n        report(new _Move_js__WEBPACK_IMPORTED_MODULE_3__.Move({\n          placements: placements,\n          words: [{ word: choice, score: score }],\n          score: score\n        }));\n      } else {\n        //console.debug(\"Rejected\",choice,\"at\",end,\"for\",score);\n      }\n    }\n  }\n}\n\n/**\n * Find the best play for the given rack. The results are reported\n * using the listener.\n * @param {Tile[]} rack rack of tiles to pick from\n * @private\n */\nfunction find(rack) {\n  // sort and reverse the rack to make sure high value letters come\n  // first and blanks come last. It's not going to make it\n  // any faster, but it will abort with a better result if\n  // it's going to time out.\n  const rackTiles = rack.sort((a, b) => {\n    return a.letter < b.letter ? -1  : a.score > b.score ? 1 : 0;\n  }).reverse();\n\n  report(\"Finding best play for rack \"\n              + rack.map(t => t.stringify()).join(\",\"));\n\n  report(`with dictionary ${dictionary.name}`);\n  report(`in edition ${edition.name}`);\n  report(\"on\\n\" + board.stringify());\n\n  //assert(dictionary instanceof Dictionary, \"Setup failure\");\n  assert(edition instanceof _Edition_js__WEBPACK_IMPORTED_MODULE_1__.Edition, \"Setup failure\");\n\n  report(\"Starting findBestPlay computation for \"\n              + rackTiles.map(t => t.stringify()).join(\",\")\n              + \" on \" + board.stringify());\n  bestScore = 0;\n\n  // Has at least one anchor been explored? If there are\n  // no anchors, we need to compute an opening play\n  let anchored = false;\n  for (let col = 0; col < board.cols; col++) {\n    for (let row = 0; row < board.rows; row++) {\n      // An anchor is any square that has a tile and has an\n      // adjacent blank that can be extended into to form a word\n      if (isAnchor(col, row)) {\n        if (!anchored) {\n          // What letters can be used to form a valid cross\n          // word? The whole alphabet if the rack contains a\n          // blank, the rack otherwise.\n          const available = rackTiles.find(l => l.isBlank)\n                ? edition.alphabet\n                : (rackTiles.filter(t => !t.isBlank)\n                   .map(t => t.letter));\n          computeCrossChecks(available);\n          anchored = true;\n        }\n        const anchorTile = board.at(col, row).tile;\n        const roots = dictionary.getSequenceRoots(anchorTile.letter);\n        for (let anchorNode of roots) {\n          // Try and back up then forward through\n          // the dictionary to find longer sequences\n          // across\n          back(\n            col, row,\n            1, 0,\n            rackTiles, 0,\n            anchorNode, anchorNode,\n            [ anchorTile ]);\n\n          // down\n          back(\n            col, row,\n            0, 1,\n            rackTiles, 0,\n            anchorNode, anchorNode,\n            [ anchorTile ]);\n        }\n      }\n    }\n  }\n\n  if (!anchored)\n    // No anchors, so this is an opening play.\n    bestOpeningPlay(rackTiles);\n}\n\n/**\n * Given a user's letter rack, compute the best possible move.\n * @param {BackendGame} game the Game\n * @param {Tile[]} rack rack in the form of a simple list of Tile\n * @param {function} listener Function that is called with a Move each time\n * a new best play is found, or a string containing a progress or error\n * message.\n * @param {string?} dictionary name of (or path to) dictionary to use,\n * defaults to game dictionary\n * @return {Promise} Promise that resolves when all best moves have been\n * identified\n */\nfunction findBestPlay(game, rack, listener, dict) {\n  report = listener;\n  board = game.board;\n  return Promise.all([\n    (0,_loadDictionary_js__WEBPACK_IMPORTED_MODULE_0__.loadDictionary)(dict)\n    .then(dic => dictionary = dic),\n\n    _Edition_js__WEBPACK_IMPORTED_MODULE_1__.Edition.load(game.edition)\n    .then(ed => edition = ed)\n  ])\n  .then(() => find(rack));\n}\n\n\n\n\n//# sourceURL=webpack://@cdot/xanado/./src/game/findBestPlay.js?");

/***/ })

}]);