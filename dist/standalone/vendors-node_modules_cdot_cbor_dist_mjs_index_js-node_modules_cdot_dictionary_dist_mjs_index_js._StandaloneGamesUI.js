"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(window["webpackChunk_cdot_xanado"] = window["webpackChunk_cdot_xanado"] || []).push([["vendors-node_modules_cdot_cbor_dist_mjs_index_js-node_modules_cdot_dictionary_dist_mjs_index_js"],{

/***/ "./node_modules/@cdot/cbor/dist/mjs/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@cdot/cbor/dist/mjs/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DataInStream\": () => (/* binding */ y),\n/* harmony export */   \"DataOutStream\": () => (/* binding */ b),\n/* harmony export */   \"Decoder\": () => (/* binding */ U),\n/* harmony export */   \"Encoder\": () => (/* binding */ A),\n/* harmony export */   \"IDREFHandler\": () => (/* binding */ I),\n/* harmony export */   \"KeyDictionaryHandler\": () => (/* binding */ v),\n/* harmony export */   \"MemoryInStream\": () => (/* binding */ P),\n/* harmony export */   \"MemoryOutStream\": () => (/* binding */ D),\n/* harmony export */   \"TagHandler\": () => (/* binding */ E),\n/* harmony export */   \"TypeMapHandler\": () => (/* binding */ F)\n/* harmony export */ });\n/*! For license information please see index.js.LICENSE.txt */\nvar t={d:(e,r)=>{for(var i in r)t.o(r,i)&&!t.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:r[i]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e)},e={};t.d(e,{rK:()=>i,Fv:()=>a,h:()=>n,hm:()=>c,P8:()=>p,Ol:()=>f,Zz:()=>s,nr:()=>d,fq:()=>r,Vy:()=>u});class r{constructor(t){this.options=t||{}}encode(t,e){return t}decode(t,e){}startEncoding(t){}finishEncoding(t){}finishDecoding(t,e){}createArray(t){return[]}createObject(t,e){return e?Object.create(e):{}}encodeKey(t,e){if(!/^_/.test(t))return t}decodeKey(t,e){return t}}class i{readFloat16(){throw Error(\"DataInStream.readFloat16\")}readFloat32(){throw Error(\"DataInStream.readFloat32\")}readFloat64(){throw Error(\"DataInStream.readFloat64\")}readUint8(){throw Error(\"DataInStream.readUint8\")}readUint16(){throw Error(\"DataInStream.readUint16\")}readUint32(){throw Error(\"DataInStream.readUint32\")}readUint64(){}readUint8Array(t){throw Error(\"DataInStream.readUint8Array\")}peekUint8(){throw Error(\"DataInStream.peekUint8\")}get mark(){throw Error(\"DataInStream.get mark\")}set mark(t){throw Error(\"DataInStream.set mark\")}}class s extends i{view=void 0;readPos=0;constructor(t){if(super(),t instanceof DataView)this.view=t;else if(t instanceof ArrayBuffer)this.view=new DataView(t,0,t.length);else{if(!t.buffer||\"number\"!=typeof t.byteLength||\"number\"!=typeof t.byteOffset)throw Error(\"MemoryInStream: data unusable\");this.view=new DataView(t.buffer,t.byteOffset,t.byteLength)}}peekUint8(){return this.view.getUint8(this.readPos)}readUint8(){const t=this.view.getUint8(this.readPos);return this.readPos+=1,t}readUint16(){const t=this.view.getUint16(this.readPos);return this.readPos+=2,t}readUint32(){const t=this.view.getUint32(this.readPos);return this.readPos+=4,t}readUint64(){return 4294967296*this.readUint32()+this.readUint32()}readFloat16(){const t=new ArrayBuffer(4),e=new DataView(t),r=this.readUint16(),i=32768&r;let s=31744&r;const n=1023&r;if(31744===s)s=261120;else if(0!==s)s+=114688;else if(0!==n)return(i?-1:1)*n*5.960464477539063e-8;return e.setUint32(0,i<<16|s<<13|n<<13),e.getFloat32(0)}readFloat32(){const t=this.view.getFloat32(this.readPos);return this.readPos+=4,t}readFloat64(){const t=this.view.getFloat64(this.readPos);return this.readPos+=8,t}readUint8Array(t){const e=new Uint8Array(this.view.buffer,this.view.byteOffset+this.readPos,t);return this.readPos+=t,e}}class n{constructor(t,e){this.stream=t,this.tagHandler=e||new r}readBreak(){return 255===this.stream.peekUint8()&&(this.stream.readUint8(),!0)}readArgument(t,e){if(t<24)return t;switch(t){case 24:return this.stream.readUint8();case 25:return this.stream.readUint16();case 26:return this.stream.readUint32();case 27:return this.stream.readUint64();case 31:switch(e){case 0:case 1:case 6:break;default:return-1}}throw Error(`Malformed ${e} ${t}`)}readIndefiniteBytes(t){const e=()=>{const e=this.stream.readUint8(),r=e>>5,i=31&e;if(31===i)return-1;if(r!==t)throw Error(`Major type mismatch on chunk ${r}!=${t}`);const s=this.readArgument(i,t);if(s<0)throw Error(`Invalid chunk length ${s}`);return s},r=[];let i,s=0;for(;(i=e())>=0;)this.debug&&this.debug(`\\tCHUNK ${i} bytes`),s+=i,r.push(this.stream.readUint8Array(i));const n=new Uint8Array(s);let a=0;for(let t=0;t<r.length;t++)n.set(r[t],a),a+=r[t].length;return n}readItemArray(t){let e=this.tagHandler.createArray(this);for(let r=0;r<t;r++)e.push(this.decodeItem());return e}readIndefiniteItemArray(){const t=this.tagHandler.createArray(this);for(;!this.readBreak();)t.push(this.decodeItem());return t}readKV(t){const e=this.tagHandler.createObject(this);for(let r=0;r<t;r++){let t=this.decodeItem();t=this.tagHandler.decodeKey(t,this),e[t]=this.decodeItem()}return e}readIndefiniteKV(){const t=this.tagHandler.createObject(this);for(;!this.readBreak();)t[this.decodeItem()]=this.decodeItem();return t}decodeItem(){const t=this.stream.readUint8(),e=t>>5,r=31&t;let i,s,n,a;switch(e){case 0:return this.debug&&this.debug(`${this.stream.readPos}: UINT ${r}`),this.readArgument(r,0);case 1:return this.debug&&this.debug(`${this.stream.readPos}: -INT ${r}`),-1-this.readArgument(r,1);case 2:if(this.debug&&this.debug(`${this.stream.readPos}: BYTES ${r}`),31===r)return this.readIndefiniteBytes(e);if(i=this.readArgument(r,2),i<0)throw Error(`Invalid byte string length ${i}`);return this.stream.readUint8Array(i);case 3:if(31===r)this.debug&&this.debug(`${this.stream.readPos}: TEXT? ${r}`),n=(new TextDecoder).decode(this.readIndefiniteBytes(e));else{if(this.debug&&this.debug(`${this.stream.readPos}: TEXT `),i=this.readArgument(r,3),i<0)throw Error(`Invalid text length ${i}`);n=(new TextDecoder).decode(this.stream.readUint8Array(i))}return this.debug&&this.debug(`\\t\"${n}\"`),n;case 4:if(31===r)return this.debug&&this.debug(`${this.stream.readPos}: ARRAY?`),this.readIndefiniteItemArray();if(i=this.readArgument(r,4),i<0)throw Error(\"Invalid array length ${len}\");return this.debug&&this.debug(`${this.stream.readPos}: ARRAY ${i}`),this.readItemArray(i);case 5:if(31===r)return this.debug&&this.debug(`${this.stream.readPos}: MAP?`),this.readIndefiniteKV();if(i=this.readArgument(r,5),i<0)throw Error(\"Invalid map length ${len}\");return this.debug&&this.debug(`${this.stream.readPos}: MAP length ${i}`),this.readKV(i);case 6:if(s=this.readArgument(r,6),this.debug&&this.debug(`${this.stream.readPos}: TAG ${s}`),a=this.tagHandler.decode(s,this),void 0!==a)return a;switch(s){case 0:case 1:return new Date(this.decodeItem())}return this.decodeItem();case 7:switch(this.debug&&this.debug(`${this.stream.readPos}: OTHER ${r}`),r){case 20:return!1;case 21:return!0;case 22:return null;case 23:return;case 24:return this.stream.readUint8();case 25:return this.stream.readFloat16();case 26:return this.stream.readFloat32();case 27:return this.stream.readFloat64()}return r}throw Error(`Unrecognised major type ${e}`)}decodes(){const t=this.decodeItem();return this.tagHandler.finishDecoding(this,t),t}static decode(t,e,r){const i=new s(t),a=new n(i,e);return a.debug=r,a.decodes()}}class a{writeUint8(t){throw Error(\"DataStream.writeUint8\")}writeUint16(t){throw Error(\"DataStream.writeUint16\")}writeUint32(t){throw Error(\"DataStream.writeUint32\")}writeUint64(t){throw Error(\"DataStream.writeUint64\")}writeFloat32(t){throw Error(\"DataStream.writeFloat32\")}writeFloat64(t){throw Error(\"DataStream.writeFloat64\")}writeUint8Array(t){for(let e=0;e<t.length;++e)this.writeUint8(this.writePos++,t[e])}}const o=2**32;class d extends a{view=new DataView(new ArrayBuffer(256));writePos=0;appendSpaceFor(t){const e=this.writePos+t,r=this.view.buffer.byteLength;let i=r;for(;i<e;)i*=2;if(i!==r){const t=new ArrayBuffer(i);new Uint8Array(t).set(new Uint8Array(this.view.buffer)),this.view=new DataView(t)}}writeUint8(t){this.appendSpaceFor(1),this.view.setUint8(this.writePos,t),this.writePos++}writeUint16(t){this.appendSpaceFor(2),this.view.setUint16(this.writePos,t),this.writePos+=2}writeUint32(t){this.appendSpaceFor(4),this.view.setUint32(this.writePos,t),this.writePos+=4}writeUint64(t){const e=t%o,r=(t-e)/o;this.writeUint32(r),this.writeUint32(e)}writeFloat32(t){this.appendSpaceFor(4),this.view.setFloat32(this.writePos,t),this.writePos+=4}writeFloat64(t){this.appendSpaceFor(8),this.view.setFloat64(this.writePos,t),this.writePos+=8}writeUint8Array(t){this.appendSpaceFor(t.length);for(let e=0;e<t.length;++e)this.view.setUint8(this.writePos++,t[e])}get Uint8Array(){return new Uint8Array(this.view.buffer,0,this.writePos)}}const h=2**53;class c{constructor(t,e){this.stream=t,this.tagger=e||new r}writeTypeAndArgument(t,e){e<24?this.stream.writeUint8(t<<5|e):e<256?(this.stream.writeUint8(t<<5|24),this.stream.writeUint8(e)):e<65536?(this.stream.writeUint8(t<<5|25),this.stream.writeUint16(e)):e<4294967296?(this.stream.writeUint8(t<<5|26),this.stream.writeUint32(e)):(this.stream.writeUint8(t<<5|27),this.stream.writeUint64(e))}writeTag(t){this.writeTypeAndArgument(6,t)}encodeItem(t){if(!1===t)return void this.stream.writeUint8(244);if(!0===t)return void this.stream.writeUint8(245);if(null===t)return void this.stream.writeUint8(246);if(void 0===t)return void this.stream.writeUint8(247);switch(typeof t){case\"number\":if(Math.floor(t)===t){if(0<=t&&t<=h)return void this.writeTypeAndArgument(0,t);if(-h<=t&&t<0)return void this.writeTypeAndArgument(1,-(t+1))}return this.stream.writeUint8(251),void this.stream.writeFloat64(t);case\"string\":{const e=(new TextEncoder).encode(t);this.writeTypeAndArgument(3,e.length),this.stream.writeUint8Array(e)}return;case\"function\":throw Error(\"Can't CBOR function\")}if(t instanceof Date)return this.writeTag(1),void this.encodeItem(t.getTime());if(void 0===(t=this.tagger.encode(t,this)))return;if(Array.isArray(t)){this.writeTypeAndArgument(4,t.length);for(let e=0;e<t.length;++e)this.encodeItem(t[e]);return}if(t instanceof Uint8Array)return this.writeTypeAndArgument(2,t.length),void this.stream.writeUint8Array(t);const e=Object.keys(t).filter((t=>void 0!==this.tagger.encodeKey(t,this))),r=e.length;this.writeTypeAndArgument(5,r);for(const r of e)this.encodeItem(this.tagger.encodeKey(r,this)),this.encodeItem(t[r])}encodes(t){this.tagger.startEncoding(this),this.encodeItem(t),this.tagger.finishEncoding(this)}static encode(t,e,r){const i=new d,s=new c(i,e);return s.debug=r,s.encodes(t),i.Uint8Array}}const u=t=>class extends t{constructor(t){super(t),this.typeMap=this.options.typeMap||{},this.pendingProto=void 0}encode(t,e){let r=t.constructor;const i=[];let s=!1;for(;r&&\"Object\"!==r.name;){if(i.push(r.name),this.typeMap[r.name]){e.writeTag(25443),e.encodeItem(r.name),s=!0,e.debug&&e.debug(`\\tTYPE_TAG ${i.join(\"-\")}`);break}r=Object.getPrototypeOf(r)}return s||!e.debug||Array.isArray(t)||e.debug(`\\tCAN'T TYPE-TAG ${i}`),super.encode(t,e)}decode(t,e){if(25443!==t)return super.decode(t,e);{const t=e.decodeItem();e.debug&&e.debug(\"Tag: CN\",t);const r=this.typeMap[t];if(!r)throw Error(`${t} missing from type map`);this.pendingProto=r.prototype}}createObject(t){let e;return this.pendingProto?(e=Object.create(this.pendingProto),this.pendingProto=void 0):e=super.createObject(t),e}},w=new RegExp(\"^ആଈ(.+)$\"),g=\"ρѓσςεรຂεϑ\";function m(t,e){const r=[];!function t(i){if(\"object\"==typeof i&&null!==i){if(Array.isArray(i)){for(const e of i)t(e);return}if(i[g])return;r.push(i),i[g]=!0;const s=Object.keys(i);for(const r of s){t(i[r]);const s=w.exec(r);s&&(i[e[s[1]]]=i[r],delete i[r])}}}(t);for(const t of r)delete t[g]}const f=t=>class extends t{constructor(t){super(t),this.k2i={},this.i2k=[],this.options.keys&&this.options.keys.forEach((t=>{this.k2i[t]=this.i2k.length,this.i2k.push(t)})),this.i2k_added=[]}finishEncoding(t){super.finishEncoding(t),t.encodeItem(this.i2k_added)}finishDecoding(t,e){super.finishDecoding(t,e);try{this.i2k_added=t.decodeItem(),this.options.debug&&this.options.debug(`Read ${this.i2k_added.length} added keys`),m(e,[...this.i2k,...this.i2k_added])}catch(t){m(e,this.i2k)}}encodeKey(t,e){if(void 0===super.encodeKey(t,this))return void(this.options.debug&&this.options.debug(`\\tKDh ignore ${t}`));if(!this.i2k)return t;let r=this.k2i[t];return void 0===r&&(this.k2i[t]=r=this.i2k.length+this.i2k_added.length,this.options.added&&this.options.added(t,r),this.i2k_added.push(t)),r}decodeKey(t,e){return t<this.i2k.length?this.i2k[t]:`ആଈ${t}`}},l=\"_Í\",p=t=>class extends t{constructor(t){super(t),this.objectsFrozen=[],this.objectsThawed={},this.currentID=void 0}finishDecoding(t,e){super.finishDecoding(t,e),this.objectsThawed={}}finishEncoding(t){super.finishEncoding(t);for(const t of this.objectsFrozen)delete t[l];this.objectsFrozen=[]}encode(t,e){if(\"object\"==typeof t){if(void 0!==t[l])return e.writeTag(25442),void e.encodeItem(t[l]);const r=this.objectsFrozen.length;e.writeTag(25444),e.encodeItem(r),t[l]=r,this.objectsFrozen.push(t)}return super.encode(t,e)}decode(t,e){let r,i;switch(t){case 25444:return this.currentID=r=e.decodeItem(),e.debug&&e.debug(\"\\tIDREF: ID=\",r),e.decodeItem();case 25442:if(i=e.decodeItem(),e.debug&&e.debug(\"\\tIDREF: REF to\",i),!this.objectsThawed[i])throw Error(`Reference to unthawed ${i}`);return this.objectsThawed[i]}return super.decode(t,e)}createArray(t){const e=super.createArray(t);return void 0!==this.currentID&&(this.objectsThawed[this.currentID]=e,t.debug&&t.debug(\"\\tIDREF: created []\",this.currentID),this.currentID=void 0),e}createObject(t,e){const r=super.createObject(t,e);return void 0!==this.currentID&&(this.objectsThawed[this.currentID]=r,t.debug&&t.debug(\"\\tIDREF: created {}\",this.currentID),this.currentID=void 0),r}};var y=e.rK,b=e.Fv,U=e.h,A=e.hm,I=e.P8,v=e.Ol,P=e.Zz,D=e.nr,E=e.fq,F=e.Vy;\n\n//# sourceURL=webpack://@cdot/xanado/./node_modules/@cdot/cbor/dist/mjs/index.js?");

/***/ }),

/***/ "./node_modules/@cdot/dictionary/dist/mjs/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@cdot/dictionary/dist/mjs/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Dictionary\": () => (/* binding */ o),\n/* harmony export */   \"Explorer\": () => (/* binding */ l),\n/* harmony export */   \"LetterNode\": () => (/* binding */ c),\n/* harmony export */   \"Trie\": () => (/* binding */ a),\n/* harmony export */   \"TrieNode\": () => (/* binding */ u)\n/* harmony export */ });\nvar t={d:(e,i)=>{for(var r in i)t.o(i,r)&&!t.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:i[r]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e)},e={};t.d(e,{Xy:()=>r,bC:()=>n,sn:()=>i,BE:()=>d,Yk:()=>h});class i{static END_OF_WORD_BIT_MASK=1;static END_OF_LIST_BIT_MASK=2;static CHILD_INDEX_SHIFT=2;static CHILD_INDEX_BIT_MASK=1073741823;next;child;isEndOfWord=!1;preNodes;preLetters;postNodes;postLetters;constructor(t){this.letter=t}eachWord(t,e){let i=this;for(;i;)i.isEndOfWord&&e(t+i.letter,i),i.child&&i.child.eachWord(t+i.letter,e),i=i.next}eachLongWord(t,e){let i=this;for(;i;)i.child?i.child.eachLongWord(t+i.letter,e):i.isEndOfWord&&e(t+i.letter,i),i=i.next}eachNode(t){let e=this;for(;e;){if(!t(e))return!1;if(e.child&&!e.child.eachNode(t))return!1;e=e.next}return!0}add(t){let e=this,r=!1;for(;e;)if(e.letter===t.charAt(0)){if(1===t.length)return e.isEndOfWord||(r=!0,e.isEndOfWord=!0),r;if(t=t.substring(1),!e.child||e.child.letter>t.charAt(0)){const n=e.child;e.child=new i(t.charAt(0)),r=!0,e.child.next=n}e=e.child}else if(!e.next||e.next.letter>t.charAt(0)){const n=e.next;e.next=new i(t.charAt(0)),r=!0,e.next.next=n}else e=e.next;return assert.fail(`Unreachable '${t}`)}buildLists(t){let e=this;for(;e;)e.preNodes=[],e.preLetters=[],e.postNodes=[],e.postLetters=[],t&&(e.preNodes.push(t),e.preLetters.push(t.letter),t.postNodes.push(e),t.postLetters.push(e.letter)),e.child&&e.child.buildLists(e),e=e.next}match(t,e){let i=this;for(;i;){if(i.letter===t[e]){if(e===t.length-1)return i;if(i.child)return i.child.match(t,e+1)}i=i.next}return null}hangmen(t,e,i,r){let n=this;const s=t[e];for(;n;)\" \"!==s&&n.letter!==s||(n.isEndOfWord&&e===t.length-1&&r.push(i+n.letter),e<t.length-1&&n.child&&n.child.hangmen(t,e+1,i+n.letter,r)),n=n.next}findWordsThatUse(t,e,i,r){let n=this;for(;n;){let s=t.indexOf(n.letter);if(s<0&&(s=t.indexOf(\" \")),s>=0){const h=t[s];if(n.isEndOfWord&&(r[e+n.letter]=i+h),t.length>1){t.splice(s,1);let d=n.child;for(;d;)d.findWordsThatUse(t,e+n.letter,i+h,r),d=d.next;t.splice(s,0,h)}}n=n.next}}decode(t,e){return 0!=(e&i.END_OF_WORD_BIT_MASK)&&(this.isEndOfWord=!0),0==(e&i.END_OF_LIST_BIT_MASK)&&(this.next=t+1),(e>>i.CHILD_INDEX_SHIFT&i.CHILD_INDEX_BIT_MASK)>0&&(this.child=e>>i.CHILD_INDEX_SHIFT&i.CHILD_INDEX_BIT_MASK),this}}class r{static cache=[];constructor(t){this.root=void 0,this.sequenceRoots=void 0,this.name=t}loadDAWG(t){const e=new DataView(t);let r=0;const n=e.getUint32(4*r++),s=[];for(let t=0;t<n;t++){const n=e.getUint32(4*r++),h=new i(String.fromCodePoint(n));h.decode(t,e.getUint32(4*r++)),s.push(h)}for(let t=0;t<s.length;t++){const e=s[t];\"number\"==typeof e.next&&(e.next=s[e.next]),\"number\"==typeof e.child&&(e.child=s[e.child])}return this.root=s[0],this}addLinks(){return this.root.buildLists(),this}eachWord(t){return this.root.eachWord(\"\",t)}match(t){return this.root.match(t,0)}hasWord(t){const e=this.root.match(t,0);return e&&e.isEndOfWord}findAnagrams(t){if((t=t.toUpperCase()).length<2)throw Error(`Dictionary: '${t}' is Too short to find anagrams`);const e=t.split(\"\"),i={};return this.root.findWordsThatUse(e,\"\",\"\",i),i}findHangmen(t){t=t.toUpperCase();const e=[];return this.root.hangmen(t,0,\"\",e),e}createSequenceRoots(){this.sequenceRoots={},this.root.eachNode((t=>(this.sequenceRoots[t.letter]?this.sequenceRoots[t.letter].push(t):this.sequenceRoots[t.letter]=[t],!0)))}getSequenceRoots(t){return this.sequenceRoots||this.createSequenceRoots(),this.sequenceRoots[t]||[]}_addWord(t){if(0===t.length)return!1;if(this.root){if(this.hasWord(t))return!1}else this.root=new i(t.charAt(0));return this.root.add(t),!0}addWord(t){return!!this._addWord(t)&&(delete this.sequenceRoots,this.root.buildLists(),!0)}findSequence(t){this.sequenceRoots||this.createSequenceRoots();const e=this.sequenceRoots[t.charAt(0)];if(!e||e.length<=0)throw Error(`Dictionary: '${t}' has no roots`);for(let i of e)if(i.match(t,0))return i;return null}hasSequence(t){return null!=this.findSequence(t)}}class n{static sequences(t,e,i){if(!(t instanceof r))throw Error(\"Not a Dictionary\");i(\"Valid sequences:\");for(let r of e)t.hasSequence(r)&&i(r)}static anagrams(t,e,i){if(!e||0===e.length)throw Error(\"Need letters to find anagrams of\");for(const r of e){let e=Object.keys(t.findAnagrams(r.replace(/\\./g,\" \")));e=e.filter((t=>t.length===r.length)),i(`${e.length} words found in \"${r}\":`),e.forEach((t=>i(t)))}}static hangmen(t,e,i){if(!e||0===e.length)throw Error(\"Need letters to find hangman matches for\");for(const r of e)t.findHangmen(r.replace(/\\./g,\" \")).forEach((t=>i(t)))}static arrangements(t,e,i){if(!e||0===e.length)throw Error(\"Need letters to find arrangements of\");for(const r of e){let e=Object.keys(t.findAnagrams(r));i(`${e.length} words found in \"${r}\":`),e.forEach((t=>i(t)))}}static list(t,e,i){if(!e||0===e.length)return void t.eachWord(((t,e)=>i(t)));const r={};e.map((e=>{const i=e.toUpperCase(),r=t.match(i);if(r)return{word:i,node:r}})).filter((t=>t)).sort(((t,e)=>t.word.length>e.word.length?-1:t.word.length===e.word.length?0:1)).map((t=>{if(t.node.child){let e=[];r[t.word]=!0,t.node.child.eachWord(t.word,(t=>e.push(t))),e=e.filter((t=>!r[t])),e.forEach((t=>r[t]=!0)),i(e.map((e=>`${t.word} -- ${e}`)).join(\"\\n\"))}}))}}let s=0;class h{letter=void 0;id=-1;next=null;child=null;isEndOfWord=!1;isFirstChild=!1;isPruned=!1;maxChildDepth=0;numberOfChildren=0;index=-1;constructor(t,e,i,r,n){this.letter=t,this.next=e,this.isEndOfWord=i,this.maxChildDepth=r,this.isFirstChild=n,this.id=s++}toString(t){let e=`{${this.id} ${this.letter}`;return this.isEndOfWord&&(e+=\".\"),this.child&&(e+=\"+\",t&&(e+=this.child.toString(t))),e+=\"}\",this.next&&(e+=\"-\",t&&(e+=this.next.toString(t))),e}prune(){this.isPruned=!0;let t=0;return this.next&&(t+=this.next.prune()),this.child&&(t+=this.child.prune()),t+1}eachWord(t,e){t.push(this),this.isEndOfWord&&e(t),this.child&&this.child.eachWord(t,e),t.pop(),this.next&&this.next.eachWord(t,e)}eachNode(t){t(this),this.next&&this.next.eachNode(t),this.child&&this.child.eachNode(t)}findChild(t){let e=this.child;for(;e;){if(e.letter===t)return e;if(e.letter>t)break;e=e.next}return null}insertChild(t,e,i){if(this.numberOfChildren++,!this.child)return void(this.child=new h(t,null,e,i,!0));if(this.child.letter>t)return this.child.isFirstChild=!1,void(this.child=new h(t,this.child,e,i,!0));let r=this.child;for(;r.next&&!(r.next.letter>t);)r=r.next;r.next=new h(t,r.next,e,i,!1)}sameSubtrie(t){return!(t!==this&&(null===t||t.letter!==this.letter||t.maxChildDepth!==this.maxChildDepth||t.numberOfChildren!==this.numberOfChildren||t.isEndOfWord!==this.isEndOfWord||!this.child&&t.child||this.child&&!t.child||!this.next&&t.next||this.next&&!t.next||this.child&&!this.child.sameSubtrie(t.child)||this.next&&!this.next.sameSubtrie(t.next)))}findSameSubtrie(t){let e;for(e=0;e<t[this.maxChildDepth].length&&!this.sameSubtrie(t[this.maxChildDepth][e]);e++);if(t[this.maxChildDepth][e].isPruned)throw Error(\"Same subtrie equivalent is pruned!\");return t[this.maxChildDepth][e]}replaceRedundantNodes(t){if(!this.next&&!this.child)return 0;let e=0;if(this.child)if(this.child.isPruned){if(this.child=this.child.findSameSubtrie(t),null===this.child)throw Error(\"Something horrible\");e++}else e+=this.child.replaceRedundantNodes(t);return this.next&&(e+=this.next.replaceRedundantNodes(t)),e}encode(){const t=[this.letter.codePointAt(0)];let e=0;return this.child&&(e|=this.child.index<<i.CHILD_INDEX_SHIFT),this.isEndOfWord&&(e|=i.END_OF_WORD_BIT_MASK),this.next||(e|=i.END_OF_LIST_BIT_MASK),t.push(e),t}}class d{numberOfWords=0;numberOfNodes=0;maxWordLen=0;minWordLen=1e6;first=new h(-1,null,!1,0,0,null,!1);_debug=()=>{};constructor(t,e){\"function\"==typeof e&&(this._debug=e),this._debug(\"\\nConstruct Trie and fill from lexicon\");for(let e of t)this.addWord(e);this._debug(`Trie of ${this.numberOfNodes} nodes built from ${this.numberOfWords} words`)}addWord(t){let e=this.first,i=0;this.maxWordLen=Math.max(this.maxWordLen,t.length),this.minWordLen=Math.min(this.minWordLen,t.length);for(let r=0;r<t.length;r++){const n=e.child?e.findChild(t[r]):null;if(!n){e.insertChild(t[r],r===t.length-1,t.length-r-1),i++,e=e.findChild(t[r]);for(let n=r+1;n<t.length;n++)e.insertChild(t[n],n===t.length-1,t.length-n-1),i++,e=e.child;break}n.maxChildDepth<t.length-r-1&&(n.maxChildDepth=t.length-r-1),e=n,r===t.length-1&&(this._debug(`WARNING input not in alphabetical order ${t}`),e.isEndOfWord=!0)}this.numberOfNodes+=i,this.numberOfWords++}eachWord(t){this.first.eachWord([],t)}createReductionStructure(){this._debug(\"\\nCreate reduction structure\");const t=[];for(let e=this.minWordLen;e<this.maxWordLen;e++)t[e]=0;const e=[],i=[];let r=this.first.child;for(;r;)i.push(r),r=r.next;let n=0;for(;i.length>0;)for(r=i.shift(),e[r.maxChildDepth]||(e[r.maxChildDepth]=[]),e[r.maxChildDepth].push(r),t[r.maxChildDepth]++,n++,r=r.child;r;)i.push(r),r=r.next;for(let e=this.minWordLen;e<this.maxWordLen;e++)t[e]>0&&this._debug(`${t[e]} words of length ${e}`);return this._debug(`${n} nodes added to the reduction structure`),e}findPrunedNodes(t){this._debug(\"\\nMark redundant nodes as pruned\");let e=0;for(let i=t.length-1;i>=0;i--){let r=0;const n=t[i];for(let t=0;t<n.length-1;t++)if(!n[t].isPruned)for(let e=t+1;e<n.length;e++)!n[e].isPruned&&n[e].isFirstChild&&n[t].sameSubtrie(n[e])&&(r+=n[e].prune());this._debug(`Pruned |${r}| nodes at depth |${i}|`),e+=r}return this._debug(`Identified a total of ${e} nodes for pruning`),e}assignIndices(){this._debug(\"\\nAssign node indices\"),this.first.child.eachNode((t=>t.index=-1));let t=this.first.child;const e=[],i=[];for(;t;)e.push(t),t=t.next;let r=0;for(;e.length>0;)if(t=e.shift(),t.index<0)for(t.index=r++,i.push(t),t=t.child;t;)e.push(t),t=t.next;return this._debug(`Assigned ${r} node indexes`),i}generateDAWG(){const t=this.createReductionStructure(),e=this.findPrunedNodes(t);let i=this.first.child.replaceRedundantNodes(t);this._debug(`Decoupled ${i} nodes to eliminate ${e} nodes`),this.numberOfNodes-=e}encode(){this._debug(\"\\nGenerate the unsigned integer array\");const t=this.assignIndices();if(t.length>1073741823)throw Error(\"Too many nodes remain for integer encoding\");this._debug(`\\t${t.length} nodes`);const e=2*t.length+1,i=new ArrayBuffer(4*e),r=new DataView(i);let n=0;r.setUint32(n,t.length),n+=4;for(let e=0;e<t.length;e++){const i=t[e].encode();r.setUint32(n,i[0]),n+=4,r.setUint32(n,i[1]),n+=4}return this._debug(`\\t${e} element Uint32Array generated`),i}}var o=e.Xy,l=e.bC,c=e.sn,a=e.BE,u=e.Yk;\n\n//# sourceURL=webpack://@cdot/xanado/./node_modules/@cdot/dictionary/dist/mjs/index.js?");

/***/ })

}]);