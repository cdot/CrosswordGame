<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: game/ServerGame.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: game/ServerGame.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*Copyright (C) 2021-2022 The Xanado Project https://github.com/cdot/Xanado
  License MIT. See README.md at the root of this distribution for full copyright
  and license information. Author Crawford Currie http://c-dot.co.uk*/
/* eslint-env amd */

define("game/ServerGame", [
	"platform", "common/Utils",
 	"dawg/Dictionary", "game/Edition", "game/Board", "game/LetterBag",
  "game/Types", "game/Commands", "game/Undo"
], (
	Platform, Utils,
  Dictionary, Edition, Board, LetterBag,
  Types, Commands, Undo
) => {
  const Notify    = Types.Notify;
  const State     = Types.State;
  const Penalty   = Types.Penalty;
  const Timer     = Types.Timer;
  const WordCheck = Types.WordCheck;
  const Turns     = Types.Turns;

  function _showData(data) {
    const s = data.toString();
    return (s === "[object Object]") ? data : s;
  }

  /**
   * Mixin that provides server-specific functionality for {@linkcode Game}
   * @mixin ServerGame
   * @mixes Commands
   * @mixes Undo
   */
  const ServerGame = {

		/**
		 * Used for testing only.
     * @function
     * @memberof ServerGame
		 * @param sboard string representation of a game {@linkcode Board}
		 * @return {Promise} resolving to `this`
		 */
		loadBoard(sboard) {
			return this.getEdition()
			.then(ed => this.board.parse(sboard, ed))
			.then(() => this);
		},

		/**
		 * Get the edition for this game, lazy-loading as necessary
     * @function
     * @memberof ServerGame
		 * @return {Promise} resolving to an {@linkcode Edition}
		 */
		getEdition() {
			return Edition.load(this.edition);
		},

		/**
		 * Get the dictionary for this game, lazy-loading as necessary
     * @function
     * @memberof ServerGame
		 * @return {Promise} resolving to a {@linkcode Dictionary}
		 */
		getDictionary() {
			if (this.dictionary)
				return Dictionary.load(this.dictionary, this.dictpath);

			// Terminal, no point in translating
			/* istanbul ignore next */
			return Promise.reject("Game has no dictionary");
		},

		/**
		 * Promise to save the game
     * @function
     * @memberof ServerGame
		 * @return {Promise} that resolves to the game when it has been saved
		 */
		save() {
			Platform.assert(this._db, "No _db for save()");
			this._debug("Saving game", this.key);
			return this._db.set(this.key, this)
			.then(() => this);
		},

		/**
		 * Check if the game has timed out due to inactivity.
		 * Stops game timers and sets the state of the game if it has.
     * @function
     * @memberof ServerGame
		 * @return {Promise} resolves to the game when timeout has
		 * been checked
		 */
		checkAge() {
			const ageInDays =
				    (Date.now() - this.lastActivity())
				    / 60000 / 60 / 24;

			if (ageInDays &lt;= 14)
				return Promise.resolve(this); // still active

			this._debug("Game", this.key, "timed out");

			this.state = State.TIMED_OUT;
			return this.save();
		},

		/**
		 * Promise to finish construction of a new Game.
		 * Load the edition and create the board and letter bag.
		 * Not done in the constructor because we need to return
		 * a Promise. Must be followed by onLoad to connect a
		 * DB and complete initialisation of private fields.
     * @function
     * @memberof ServerGame
		 * @return {Promise} that resolves to this
		 */
		create() {
			// Can't be done in the constructor because we have to
			// return a Promise.
		  this.creationTimestamp = Date.now();
		  this.key = Utils.genKey();
      this.state = State.WAITING;
			return this.getEdition()
			.then(edo => {
				this.board = new Board(edo);
				this.letterBag = new LetterBag(edo);
        this.bonuses = edo.bonuses;
				this.rackSize = edo.rackCount;
				this.swapSize = edo.swapCount;
				return this;
			});
		},

		/**
		 * Promise to finish the construction or load from serialisation
		 * of a game.
		 * A game has to know what DB so it knows where to save. The
		 * database and connections are not serialised, and must be
		 * reset. Only available server-side.
     * @function
     * @memberof ServerGame
		 * @param {Database} db the db to use to store games
		 * @return {Promise} Promise that resolves to the game
		 */
		onLoad(db) {
			// if this onLoad follows a load from serialisation, which
      // does not invoke the constructor.
			// We always set the _db

      /**
		   * Database containing this game. Only available server-side,
       * and not serialised.
		   * @member {Database}
       * @private
		   */
			this._db = db;

      /**
		   * List of decorated sockets. Only available server-side, and
       * not serialised.
		   * @member {WebSocket[]}
       * @private
		   */
      this._connections = [];

      if (!this._debug) {
        this._debug = () => {};
        this.players.forEach(p => p._debug = this._debug);
      }

			return Promise.resolve(this);
		},

		/**
		 * Add a player to the game, and give them an initial rack
     * @function
     * @memberof ServerGame
		 * @param {Player} player
		 * @param {boolean?} fillRack true to fill the player's rack
     * from the game's letter bag.
     * @return {Game} this
		 */
		addPlayer(player, fillRack) {
			Platform.assert(this.letterBag, "Cannot addPlayer() before create()");
			Platform.assert(
        !this.maxPlayers || this.players.length &lt; this.maxPlayers,
				"Cannot addPlayer() to a full game");
			player._debug = this._debug;
			this.players.push(player);
			this._debug(this.key, "added player", player.toString());
			if (this.timerType)
				player.clock = this.timeLimit;
      if (fillRack)
        player.fillRack(this.letterBag, this.rackSize);
      return this;
		},

		/**
		 * Remove a player from the game, taking their tiles back into
		 * the bag
     * @function
     * @memberof ServerGame
		 * @param {Player} player
		 */
		removePlayer(player) {
			player.returnTiles(this.letterBag);
			const index = this.players.findIndex(p => p.key === player.key);
			Platform.assert(index >= 0,
				              `No such player ${player.key} in ${this.key}`);
			this.players.splice(index, 1);
			this._debug(player.key, "left", this.key);
			if (this.players.length &lt; (this.minPlayers || 2)
          &amp;&amp; this.state !== State.GAME_OVER)
				this.state = State.WAITING;
		},

    /**
		 * Send a message to just one player. Note that the player
		 * may be connected multiple times through different sockets.
		 * Only available server-side.
     * @function
     * @memberof ServerGame
		 * @param {Player} player player to send to
		 * @param {string} message to send
		 * @param {Object} data to send with message
		 */
		notifyPlayer(player, message, data) {
			this._debug("&lt;-S-", player.key, message, _showData(data));
			// Player may be connected several times
			this._connections.forEach(
				socket => {
					if (socket.player === player)
						socket.emit(message, data);
					return false;
				});
		},

		/**
		 * Broadcast a message to all game observers. Note
     * that an observer may be connected multiple times,
     * through different sockets.
     * @function
     * @memberof ServerGame
		 * @param {string} message to send
		 * @param {Object} data to send with message
		 */
		notifyAll(message, data) {
			if (message !== Notify.TICK)
        this._debug("&lt;-S- *", message, _showData(data));
			this._connections.forEach(socket => socket.emit(message, data));
		},

		/**
		 * Broadcast a message to all observers players except the
     * given player.
     * @function
     * @memberof ServerGame
		 * @param {Player} player player to exclude
		 * @param {string} message to send
		 * @param {Object} data to send with message
		 */
		notifyOthers(player, message, data) {
			this._debug("&lt;-S- !", player.key, message, _showData(data));
			// Player may be connected several times
			this._connections.forEach(
				socket => {
					if (socket.player.key !== player.key)
						socket.emit(message, data);
					return false;
				});
		},

		/**
		 * Start, or continue, playing the game if preconditions are met.
     * @function
     * @memberof ServerGame
		 * @return {Promise} promise that resolves to the game
		 */
		playIfReady() {
			this._debug("playIfReady ", this.key,
                  this.whosTurnKey ? `player ${this.whosTurnKey}` : "",
                  "state", this.state);

			if (this.hasEnded()) {
				this._debug("\tgame is over");
				return Promise.resolve(this);
			}

			// Check preconditions for starting the game
			if (this.players.length &lt; (this.minPlayers || 2)) {
				this._debug("\tnot enough players");
				// Result is not used
				return Promise.resolve(this);
			}

			// If no turn has been allocated yet, 
			// shuffle the players, and pick a random tile from the bag.
			// The shuffle can be suppressed for unit testing.
			if (this.state === State.WAITING) {
				this._debug("\tpreconditions met");

				if (this.players.length > 1 &amp;&amp; !this._noPlayerShuffle) {
					this._debug("\tshuffling player order");
					for (let i = this.players.length - 1; i > 0; i--) {
						const j = Math.floor(Math.random() * (i + 1));
						// i = 1, j = 0,1
						//    j = 0, swap 0 and 1
						//    j = 1, leave 1 in place
						const temp = this.players[i];
						this.players[i] = this.players[j];
						this.players[j] = temp;
					}
					// Notify all connections of the order change
					// (asynchronously)
					this.updateConnections();
				}

				const player = this.players[0];
				this.whosTurnKey = player.key; // assign before save()
        this._debug(`\t${player.key} to play`);
				this.state = State.PLAYING;

				return this.save()
				// startTurn will autoplay if the first player is
				// a robot. It will also start the clock.
				.then(() => this.startTurn(player));
			}

			const nextPlayer = this.getPlayer();
			if (nextPlayer) {
        if (nextPlayer.isRobot)
				  return this.startTurn(nextPlayer);

			  this._debug("\twaiting for", nextPlayer.name, "to play");
        this.startTheClock();
      }
			return Promise.resolve(this);
		},

		/**
		 * Wrap up after a command handler that is returning a Turn.
		 * Log the command, determine whether the game has ended,
		 * save state and notify connected players with the Turn object.
     * @function
     * @memberof ServerGame
		 * @param {Turn} turn the Turn to finish
		 * @return {Promise} that resolves to the game
		 */
		finishTurn(turn) {
			turn.timestamp = Date.now();

			// store turn log
			this.turns.push(turn);

			// TODO: the results of a turn should not simply be broadcast,
			// because a client could intercept and reconstruct other
			// player's racks from the results. Really there should be
			// one turn broadcast, and a different turn sent to the
			// playing player.
			return this.save()
			.then(() => this.notifyAll(Notify.TURN, turn))
			.then(() => this);
		},

		/**
		 * Does player have an active connection to this game?
     * @function
     * @memberof ServerGame
		 * @param {Player} player the player
		 * @return {WebSocket} a decorated socket, or null if not connected.
		 */
		getConnection(player) {
			for (let socket of this._connections) {
				if (socket.player === player) {
          player.isConnected = true;
					return socket;
        }
			}
      if (player)
        player.isConnected = false;
			return null;
		},

		/**
		 * Notify observers with a list of the currently connected
     * observers and non-connected players. Only available
     * server-side.
     * @function
     * @memberof ServerGame
		 */
		updateConnections() {
			Promise.all(
				this.players
				.map(player => player.simple(this)
					   .then(cat => {
						   cat.gameKey = this.key;
						   if (cat.key === this.whosTurnKey)
							   cat.isNextToGo = true;
               cat.toString = () => `${cat.name}/${cat.key}`;
						   return cat;
					   })))
			.then(res => {
        // Add observers who are not active players. These track
        // game state without participating, though at some point
        // we may add referreing functions.
        res = res.concat(
          this._connections
          .filter(socket => !socket.player)
          .map(socket => {
            return {
              isObserver: true
            };
          }));
        this.notifyAll(Notify.CONNECTIONS, res);
      });
		},

		/**
		 * Start (or restart) the turn of the given player.
     * @function
     * @memberof ServerGame
		 * @param {Player?} player the the player to get the turn.
		 * @param {number?} timeout Only relevant when `timerType` is
		 * `Timer.TURN`. Turn timeout for this turn. Set if
		 * this is a restart of an unfinished turn, defaults to
		 * this.timeLimit if undefined.
		 * @return {Promise} a promise that resolves to undefined
     * @private
		 */
		startTurn(player, timeout) {
			Platform.assert(player, "No player");

			if (!this.players.find(p => p.passes &lt; 2))
				return this.confirmGameOver(player, State.TWO_PASSES);

			this._debug("startTurn", player.name, player.key);

			this.whosTurnKey = player.key;

			if (player.isRobot) {
				// May recurse if the player after is also a robot, but
				// the recursion will always stop when a human player
				// is reached, so never deep.
				return this.autoplay();
			}

			// For a timed game, make sure the clock is running and
			// start the player's timer.

      if (this.timerType) {
			  this._debug("\ttimed game,", player.name,
                    "has", (timeout || this.timeLimit), "left to play",this.timerType);
			  this.startTheClock(); // does nothing if already started
      }
			else {
				this._debug(
					`\tuntimed game, wait for ${player.name} to play`);
				return Promise.resolve(this);
			}

			if (this.timerType === Timer.TURN)
				// Make the player pass when their clock reaches 0
				player.setTimeout(
					timeout || this.timeLimit,
					() => this.pass(player, Turns.TIMED_OUT));

			return Promise.resolve(this);
		},

		/**
		 * Player is on the given socket, as determined from an incoming
		 * 'join'. Play the game if preconditions have been met.  Only
		 * available server side.
     * @function
     * @memberof ServerGame
		 * @param {WebSocket} socket the connecting socket
		 * @param {string} playerKey the key identifying the player
		 * @return {Promise} promise that resolves to undefined
		 */
		connect(socket, playerKey) {

			// Make sure this is a valid (known) player
			const player = this.players.find(p => p.key === playerKey);
			/* istanbul ignore if */
			if (playerKey &amp;&amp; !player)
				console.error("WARNING: player key", playerKey,
                      "not found in game", this.key);

			/* istanbul ignore if */
			if (this.getConnection(player)) {
				console.error("WARNING:", playerKey, "already connected to",
							        this.key);
        player.isConnected = true;
			} else if (player) {
				// This player is just connecting
				this._debug(`\t${player.name} connected to ${this.key}`);
        player.isConnected = true;
			} else
        this._debug("\tconnected non-player");

			// Player is connected. Decorate the socket. It may seem
			// rather cavalier, writing over the socket this way, but
			// it does simplify the code quite a bit.
			socket.game = this;
			socket.player = player;

			this._connections.push(socket);

			// Tell players that the player is connected
			this.updateConnections();

			// Add disconnect listener
			/* istanbul ignore next */
			socket.on("disconnect", () => {
				if (socket.player) {
          socket.player.isConnected = false;
          this._debug(socket.player.name, "disconnected");
				} else
          this._debug("non-player disconnected");
				this._connections.splice(this._connections.indexOf(socket), 1);
				this.updateConnections();
			});

			return this.playIfReady();
		},

		/**
		 * Tell all clients a tick has happened (or
		 * remind them of the current number of seconds to play)
     * @function
     * @memberof ServerGame
     * @private
		 */
		tick() {
			const player = this.getPlayer();
			if (!player)
				return;

			player.tick();

			// Really should save(), otherwise the ticks won't
			// survive a server restart. However it's expensive, and server
			// restarts are rare, so let's not.
			this.notifyAll(
				Notify.TICK,
				{
					gameKey: this.key,
					playerKey: player.key,
					clock: player.clock,
					timestamp: Date.now()
				});
		},

		/**
		 * If the game has a time limit, start an interval timer.
     * @function
     * @memberof ServerGame
     * @return {boolean} true if the clock is started, false otherwise
     * (e.g. if it is already running)
		 * @private
		 */
		startTheClock() {
			if (typeof this._intervalTimer === "undefined"
          &amp;&amp; this.timerType
          &amp;&amp; this.state === State.PLAYING) {
      
			  // Broadcast a ping every second
		    /**
		     * Timer object for ticking.
		     * @member {object?}
         * @private
		     */
			  this._intervalTimer = setInterval(() => this.tick(), 1000);
			  this._debug(this.key, "started the clock");
			  return true;
      }
      return false;
		},

		/**
		 * Stop the interval timer, if there is one
     * @function
     * @memberof ServerGame
     * @return {boolean} true if the clock is stopped, false otherwise
		 * @private
		 */
		stopTheClock() {
			if (typeof this._intervalTimer == "undefined")
        return false;
			this._debug(this.key, "stopped the clock");
			clearInterval(this._intervalTimer);
			delete(this._intervalTimer);
			return true;
		},

		/**
		 * Robot play for the current player. This may result in a challenge.
     * @function
     * @memberof ServerGame
		 * @return {Promise} resolving to this
		 */
		autoplay() {
			const player = this.getPlayer();
			this._debug("Autoplaying", player.name,
                  "using", player.dictionary || this.dictionary);

			// Before making a robot move, consider challenging the last
			// player.
			// challenge is a Promise that will resolve to true if a
			// challenge is made, or false otherwise.
			let challenge = Promise.resolve(false);
      let lastPlay = this.lastPlay();
			if (lastPlay
				  &amp;&amp; this.dictionary
				  &amp;&amp; player.canChallenge) {
				const lastPlayer = this.getPlayerWithKey(lastPlay.playerKey);
				// There's no point if they are also a robot, though
				// that should never arise in a "real" game where there can
				// only be one robot.
				if (!lastPlayer.isRobot) {
					// use game dictionary, not robot dictionary
					challenge = this.getDictionary()
					.then(dict => {
						const bad = lastPlay.words
							    .filter(word => !dict.hasWord(word.word));
						if (bad.length > 0) {
							// Challenge succeeded
							this._debug(`Challenging ${lastPlayer.name}`);
							this._debug(`Bad words: `, bad);
							return this.takeBack(player, Turns.CHALLENGE_WON)
							.then(() => true);
						}
						return false; // no challenge made
					});
				}
			}

			return challenge
			.then(challenged => {
				// if (challenged) then the challenge succeeded, so at
				// least one other player can play again.
				// Challenge cannot fail - robot never challenges unless
				// it is sure it will win.
				if (!challenged &amp;&amp; lastPlay) {
					// Last play was good, check the last player has tiles
					// otherwise the game is over
					const lastPlayer = this.getPlayerWithKey(lastPlay.playerKey);
					if (lastPlayer.rack.isEmpty())
						return this.confirmGameOver(player, State.GAME_OVER);
				}

				let bestPlay = null;
				return Platform.findBestPlay(
					this, player.rack.tiles(),
					data => {
						if (typeof data === "string")
							this._debug(data);
						else {
							bestPlay = data;
							this._debug("Best", bestPlay.toString());
						}
					}, this.dictpath, player.dictionary || this.dictionary)
				.then(() => {
					if (bestPlay)
						return this.play(player, bestPlay);

					this._debug(`${player.name} can't play, passing`);
					return this.pass(player, Turns.PASSED);
				});
			});
		}
  };

  // Mix-ins
  Object.assign(ServerGame, Commands);
  Object.assign(ServerGame, Undo);

  return ServerGame;
});
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-dawg_compressor.html">dawg/compressor</a></li><li><a href="module-dawg_explore.html">dawg/explore</a></li><li><a href="module-design_valett.html">design/valett</a></li><li><a href="module-game_findBestPlay.html">game/findBestPlay</a></li></ul><h3>Classes</h3><ul><li><a href="Board.html">Board</a></li><li><a href="BrowserPlatform.html">BrowserPlatform</a></li><li><a href="Database.html">Database</a></li><li><a href="Dialog.html">Dialog</a></li><li><a href="Dictionary.html">Dictionary</a></li><li><a href="Edition.html">Edition</a></li><li><a href="FileDatabase.html">FileDatabase</a></li><li><a href="Fridge.html">Fridge</a></li><li><a href="Game.html">Game</a></li><li><a href="GamesUI.html">GamesUI</a></li><li><a href="GameUI.html">GameUI</a></li><li><a href="LetterBag.html">LetterBag</a></li><li><a href="LetterNode.html">LetterNode</a></li><li><a href="Move.html">Move</a></li><li><a href="Platform.html">Platform</a></li><li><a href="Player.html">Player</a></li><li><a href="Rack.html">Rack</a></li><li><a href="Replay.html">Replay</a></li><li><a href="Server.html">Server</a></li><li><a href="ServerPlatform.html">ServerPlatform</a></li><li><a href="Square.html">Square</a></li><li><a href="Surface.html">Surface</a></li><li><a href="Tile.html">Tile</a></li><li><a href="Trie.html">Trie</a></li><li><a href="TrieNode.html">TrieNode</a></li><li><a href="Turn.html">Turn</a></li><li><a href="UI.html">UI</a></li><li><a href="UserManager.html">UserManager</a></li><li><a href="XanadoPass.html">XanadoPass</a></li></ul><h3>Mixins</h3><ul><li><a href="BrowserGame.html">BrowserGame</a></li><li><a href="Commands.html">Commands</a></li><li><a href="ServerGame.html">ServerGame</a></li><li><a href="Undo.html">Undo</a></li></ul><h3>Global</h3><ul><li><a href="global.html#allow">allow</a></li><li><a href="global.html#challenge">challenge</a></li><li><a href="global.html#confirmGameOver">confirmGameOver</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.7</a> on Wed Jul 13 2022 12:21:51 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
