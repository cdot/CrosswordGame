<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: dawg/TrieNode.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: dawg/TrieNode.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*Copyright (C) 2019-2022 The Xanado Project https://github.com/cdot/Xanado
  License MIT. See README.md at the root of this distribution for full copyright
  and license information. Author Crawford Currie http://c-dot.co.uk*/
/* eslint-env amd, node */

define([
  "dawg/LetterNode"
], LetterNode => {

  let nodeIds = 0;

  /**
   * A Trie/DAWG node.
   * Represents a letter in a set of words.  It has pointers to a
   * child list representing the next letters that can follow this
   * letter, and a next pointer to the next alternative to this
   * letter in the child list of it's parent node.  Note this is
   * only used while generating a DAWG from a lexicon. TrieNodes are
   * serialised using the above structure but are then rebuilt using
   * {@linkcode LetterNode}s at the sharp end.
   */
  class TrieNode {
    /**
     * The letter at this node
     * @member {string}
     */
    letter = undefined;

    /**
     * Unique ID for this node, purely used for debugging
     * @member {number}
     */
    id = -1;

    /**
     * Pointer to the next alternative to this letter
     * @member {TrieNode}
     */
    next = null;

    /**
     * Pointer to the first next letter if this letter is matched
     * @member {TrieNode}
     */
    child = null;

    /**
     * Marker for a valid end-of-word node
     * @member {boolean}
     */
    isEndOfWord = false;

    /**
     * Marker for the first child under a parent node. This is
     * used when the node is arrived at other than through the
     * parent
     * @member {boolean}
     */
    isFirstChild = false;

    /**
     * Will be set if the node is to be pruned after DAWG generation
     * @member {boolean}
     */
    isPruned = false;

    /**
     * Maximum number of nodes under this node (iei remaining length
     * of the longest word this node partiipates in)
     * @member {number}
     */
    maxChildDepth = 0;

    /**
     * Number of child nodes under this node - used for optimisation
     * @member {number}
     */
    numberOfChildren = 0;

    /**
     * Index of the node in the encoded DAWG, assigned when the
     * encoding is generated
     * @member {number}
     */
    index = -1;

    /**
     * @param {string} letter codepoint
     * @param {TrieNode} next next node pointer
     * @param {boolean} isWordEnding true if this is an end-of-word node
     * @param {number} starterDepth The maximum depth below this
     * node before the end-of-word is reached, for the first word
     * added
     * @param {boolean} isFirstChild is the first child of the parent node
     */
    constructor(letter, next, isWordEnding, starterDepth, isFirstChild) {
      this.letter = letter;
      this.next = next;
      this.isEndOfWord = isWordEnding;
      this.maxChildDepth = starterDepth;
      this.isFirstChild = isFirstChild;
      this.id = nodeIds++;
    }

    /* istanbul ignore next */
    /**
     * Debug
     * @param {boolean} deeply true to expand child nodes
     */
    toString(deeply) {
      let simpler = `{${this.id} ${this.letter}`;

      if (this.isEndOfWord)
        simpler += ".";
      if (this.child) {
        simpler += "+";
        if (deeply)
          simpler += this.child.toString(deeply);
      }
      simpler += "}";
      if (this.next) {
        simpler += "-";
        if (deeply)
          simpler += this.next.toString(deeply);
      }

      return simpler;
    }

    /**
     * Mark a node as pruned, and recursively mark every node
     * under and after it as well
     * @return {number} the total number of nodes pruned as a result
     */
    prune() {
      //console.debug(`Pruning ${this}`);
      this.isPruned = true;

      let result = 0;
      if (this.next)
        result += this.next.prune();

      if (this.child)
        result += this.child.prune();

      return result + 1;
    }

    /**
     * @callback TrieNode~wordCallback
     * @param {TrieNode} nodes list of nodes on the path
     * from the root to the end of the word
     */

    /**
     * Depth-first tree walk. Will visit ends of words in
     * sorted order.
     * @param {TrieNode[]} nodes list of nodes visited to create the word
     * @param {TrieNode~wordCallback} cb callback function
     * @private
     */
    eachWord(nodes, cb) {

      nodes.push(this);

      if (this.isEndOfWord)
        cb(nodes);

      if (this.child)
        this.child.eachWord(nodes, cb);

      nodes.pop();

      if (this.next)
        this.next.eachWord(nodes, cb);
    }

    eachNode(cb) {
      cb(this);
      if (this.next)
        this.next.eachNode(cb);
      if (this.child)
        this.child.eachNode(cb);
    }

    /**
     * Search along this's child next chain for a node with the
     * given letter.
     * @param {string} thisLetter letter to look for
     * @return {TrieNode} the node found, or null
     */
    findChild(thisLetter) {
      let result = this.child;
      while (result) {
        if (result.letter === thisLetter)
          return result;
        if (result.letter > thisLetter)
          break;
        result = result.next;
      }
      return null;
    }

    /**
     * Insert a letter in the child list of this node. The child
     * list is sorted on letter
     * @param {string} thisLetter letter to add
     * @param {boolean} wordEnder true if this is the end of a word
     * @param {number} startDepth depth of shallowest node
     */
    insertChild(thisLetter, wordEnder, startDepth) {
      this.numberOfChildren++;

      if (!this.child) {
        // child list does not exist yet
        this.child = new TrieNode(
          thisLetter, null, wordEnder, startDepth, true);
        return;
      }

      if (this.child.letter > thisLetter) {
        // thisLetter should be the first in the child list
        this.child.isFirstChild = false;
        this.child = new TrieNode(
          thisLetter, this.child, wordEnder, startDepth, true);
        return;
      }

      // thisLetter is not the first in the list
      let child = this.child;
      while (child.next) {
        if (child.next.letter > thisLetter)
          break;
        child = child.next;
      }
      child.next = new TrieNode(
        thisLetter, child.next, wordEnder, startDepth, false);
    }

    /**
     * Determine if this and other are the parent nodes
     * of equal Trie branches.
     * @param {TrieNode} other other tree to compare
     * @return {boolean} if the are the same
     */
    sameSubtrie(other) {
      //console.debug("CMP",this.toString(), !other ? "null" : other.toString());
      if (other === this) // identity
        return true;

      if (other === null
          || other.letter !== this.letter
          || other.maxChildDepth !== this.maxChildDepth
          || other.numberOfChildren !== this.numberOfChildren
          || other.isEndOfWord !== this.isEndOfWord
          || !this.child &amp;&amp; other.child
          || this.child &amp;&amp; !other.child
          || !this.next &amp;&amp; other.next
          || this.next &amp;&amp; !other.next)
        return false;

      if (this.child &amp;&amp; !this.child.sameSubtrie(other.child))
        return false;

      if (this.next &amp;&amp; !this.next.sameSubtrie(other.next))
        return false;

      return true;
    }

    /**
     * Returns the first node in the red[maxChildDepth], that is
     * identical to 'this'. If the function returns 'this'
     * then it is the first of its kind in the
     * Trie.
     * @param {TrieNode[][]} red reduction structure
     * @return {TrieNode}
     * @private
     */
    findSameSubtrie(red) {
      //return red[this.maxChildDepth].find(n => this.sameSubtrie(n));
      let x;
      for (x = 0; x &lt; red[this.maxChildDepth].length; x++)
        if (this.sameSubtrie(red[this.maxChildDepth][x]))
          break;
      /* istanbul ignore if */
      if (red[this.maxChildDepth][x].isPruned)
        throw Error("Same subtrie equivalent is pruned!");
      return red[this.maxChildDepth][x];
    }

    /**
     * Recursively replaces all redundant nodes in a trie with their
     * first equivalent.
     * @param {TrieNode[][]} red reduction structure
     * @return {number} no of nodes replaced
     */
    replaceRedundantNodes(red) {

      if (!this.next &amp;&amp; !this.child)
        // Leaf node
        return 0;

      let trimmed = 0;
      if (this.child) {
        if (this.child.isPruned) {
          //console.debug(`Trimming ${this.child}`);
          // we have found a node that has been tagged for
          // as pruned, so let us replace it with its first
          // equivalent which isn't tagged.
          this.child = this.child.findSameSubtrie(red);
          /* istanbul ignore if */
          if (this.child === null)
            throw Error("Something horrible");
          trimmed++;
        } else
          trimmed += this.child.replaceRedundantNodes(red);
      }

      // Traverse the rest of the 'Trie', but a 'TrieNode' that is
      // not a direct child will never be directly replaced.
      // This will allow the resulting 'Dawg' to fit into a
      // contiguous array of node lists.
      if (this.next)
        trimmed += this.next.replaceRedundantNodes(red);

      return trimmed;
    }

    /**
     * Encode the node in a pair of integers. Requires node indices to have
     * been established.
     * @return {number[]} array with the 2-integer encoding
     */
    encode() {
      const array = [ this.letter.codePointAt(0) ];
      let numb = 0;
      if (this.child)
        numb |= (this.child.index &lt;&lt; LetterNode.CHILD_INDEX_SHIFT);
      if (this.isEndOfWord)
        numb |= LetterNode.END_OF_WORD_BIT_MASK;
      if (!this.next)
        numb |= LetterNode.END_OF_LIST_BIT_MASK;
      array.push(numb);
      return array;
    }
  }

  return TrieNode;
});
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-design_valett.html">design/valett</a></li><li><a href="module-dictionary_compressor.html">dictionary_compressor</a></li><li><a href="module-explore.html">explore</a></li></ul><h3>Classes</h3><ul><li><a href="Board.html">Board</a></li><li><a href="BrowserGame.html">BrowserGame</a></li><li><a href="BrowserPlatform.html">BrowserPlatform</a></li><li><a href="BrowserSurface.html">BrowserSurface</a></li><li><a href="Database.html">Database</a></li><li><a href="Dictionary.html">Dictionary</a></li><li><a href="Edition.html">Edition</a></li><li><a href="FileDatabase.html">FileDatabase</a></li><li><a href="Fridge.html">Fridge</a></li><li><a href="Game.html">Game</a></li><li><a href="GameDialog.html">GameDialog</a></li><li><a href="GamesUI.html">GamesUI</a></li><li><a href="GameUI.html">GameUI</a></li><li><a href="InvitePlayersDialog.html">InvitePlayersDialog</a></li><li><a href="LetterBag.html">LetterBag</a></li><li><a href="LetterNode.html">LetterNode</a></li><li><a href="LoginDialog.html">LoginDialog</a></li><li><a href="Move.html">Move</a></li><li><a href="Platform.html">Platform</a></li><li><a href="Player.html">Player</a></li><li><a href="Rack.html">Rack</a></li><li><a href="Server.html">Server</a></li><li><a href="ServerGame.html">ServerGame</a></li><li><a href="ServerPlatform.html">ServerPlatform</a></li><li><a href="Square.html">Square</a></li><li><a href="Surface.html">Surface</a></li><li><a href="Tile.html">Tile</a></li><li><a href="Trie.html">Trie</a></li><li><a href="TrieNode.html">TrieNode</a></li><li><a href="Turn.html">Turn</a></li><li><a href="UI.html">UI</a></li><li><a href="UserManager.html">UserManager</a></li><li><a href="XanadoPass.html">XanadoPass</a></li></ul><h3>Mixins</h3><ul><li><a href="BrowserBoard.html">BrowserBoard</a></li><li><a href="BrowserMove.html">BrowserMove</a></li><li><a href="BrowserPlayer.html">BrowserPlayer</a></li><li><a href="BrowserSquare.html">BrowserSquare</a></li><li><a href="BrowserTile.html">BrowserTile</a></li><li><a href="Commands.html">Commands</a></li><li><a href="PasswordMixin.html">PasswordMixin</a></li><li><a href="Replay.html">Replay</a></li><li><a href="ServerBoard.html">ServerBoard</a></li><li><a href="Undo.html">Undo</a></li></ul><h3>Global</h3><ul><li><a href="global.html#createDialog">createDialog</a></li><li><a href="global.html#game/findBestPlay">game/findBestPlay</a></li><li><a href="global.html#step">step</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.7</a> on Thu Oct 13 2022 10:55:24 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
