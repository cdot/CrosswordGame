/* See README.md at the root of this distribution for copyright and
   license information */
/* eslint-env node, mocha */

requirejs = require("requirejs");
// node.js
const { JSDOM } = require("jsdom");
/* eslint-disable no-global-assign */
document = new JSDOM("<!doctype html><html><body id='working'></body></html>");
/* eslint-enable no-global-assign */
const { window } = document;
global.window = window;
global.document = window.document;
global.navigator = { userAgent: "node.js" };
const jQuery = require("jquery");
global.jQuery = jQuery;
global.$ = jQuery;
jQuery.i18n = s => s;

requirejs.config({
    baseUrl: `${__dirname}/..`,
	nodeRequire: require,
	paths: {
		common: "js/common",
		"jquery-ui": "node_modules/jquery-ui-dist/jquery-ui",
		game: "js/game",
		dawg: "js/dawg",
		platform: "js/server/ServerPlatform"
	}
});

/**
 * Basic unit tests for Game class. More tests for Game methods are
 * in Challenges, HumanCommands, RobotPlays and TimedGame.
 */
describe("Game - basic tests", () => {
	
	const deps = [
		{ TestSocket: "test/TestSocket" },
		{ Tile: "game/Tile" },
		{ Player: "game/Player" },
		{ Game: "game/Game" },
		{ Move: "game/Move" },
		{ Turn: "game/Turn" },
		{ Notify: "game/Notify" },
		{ Command: "game/Command" },
		{ Platform: "platform" }
	];

	const Assert = require("./Assert.js");
	before(required =>
           Assert.depend(() => Platform.i18n().load("qqq").then(required), deps));

	function unit() {}

	it("construct and simple", () => {
		const p = {
			edition:"English_Scrabble",
			dictionary:"Oxford_5000",
			timerType: Player.TIMER_GAME,
			timeLimit: 60,
			timeLimitMinutes: 999, // timeLimit should override
			timePenalty: 100,
			predictScore: true,
			allowTakeBack: true,
			wordCheck: Game.WORD_CHECK_AFTER,
			minPlayers: 5,
			//debug: console.debug,
			maxPlayers: 10
		};
		let game;
		return new Game(p)
		.create()
		.then(g => game = g)
		.then(() => {
			assert.equal(game.edition, p.edition);
			assert.equal(game.dictionary, p.dictionary);
			assert.equal(game.timerType, Player.TIMER_GAME);
			assert.equal(game.timePenalty, 100);
			assert.equal(game.timeLimit, 60);
			assert(game.predictScore);
			assert(game.allowTakeBack);
			assert(game.wordCheck);
			assert.equal(game.minPlayers, 5);
			assert.equal(game.maxPlayers, 10);
			assert.equal(game.state, Game.STATE_WAITING);
			return game.simple();
		})
		.then(s => {
			assert.equal(s.key, game.key);
			assert.equal(s.creationTimestamp, game.creationTimestamp);
			assert.equal(s.edition, game.edition);
			assert.equal(s.dictionary, game.dictionary);
			assert.equal(s.predictScore, game.predictScore);
			assert.equal(s.wordCheck, game.wordCheck);
			assert.equal(s.allowTakeBack, game.allowTakeBack);
			assert.equal(s.state, game.state);
			assert.equal(s.turns, game.turns.length);
			assert.equal(s.whosTurnKey, game.whosTurnKey);
			assert.equal(s.timerType, game.timerType);
			assert.equal(s.timeLimit, game.timeLimit);
			assert.equal(s.timePenalty, game.timePenalty);
			assert.equal(s.pausedBy, game.pausedBy);
			assert.equal(s.minPlayers, game.minPlayers);
			assert.equal(s.maxPlayers, game.maxPlayers);
			assert.equal(s.penaltyType, game.penaltyType);
			assert.equal(s.penaltyPoints, game.penaltyPoints);
			assert.equal(s.nextGameKey, game.nextGameKey);
			assert.equal(s.lastActivity, game.lastActivity());
			assert.equal(s.players.length, 0);
		});
	});
	
	it("basics", () => {
		const p = {
			//debug: console.debug,
			edition:"English_Scrabble",
			dictionary:"Oxford_5000",
			timerType: Player.TIMER_TURN,
			timeLimitMinutes: 999,
			predictScore: false,
			allowTakeBack: false,
			wordCheck: Game.WORD_CHECK_AFTER,
			minPlayers: 30,
			maxPlayers: 1
		};

		const game = new Game(p);
		const robot1 = new Player({
			name:"Robot 1", key:"robot1", isRobot: true});
		const human2 = new Player({
			name:"human2", key:"human2", isRobot: false});
		const human3 = new Player({
			name:"human3", key:"human3", isRobot: false});
		const um = { // UserManager fixture
			getUser: k => Promise.resolve({ email: k.key + "@players.com" })
		};
		
		return game.create()
		.then(() => {
			assert.equal(game.edition, p.edition);
			assert.equal(game.dictionary, p.dictionary);
			assert.equal(game.timeLimit, 999*60);
			assert(!game.predictScore);
			assert(!game.allowTakeBack);
			assert.equal(game.wordCheck, Game.WORD_CHECK_AFTER);
			assert.equal(game.minPlayers, 30);
			assert.equal(game.maxPlayers, 0);

			game.addPlayer(robot1);
			game.addPlayer(human2);
			game.addPlayer(human3);
			game.whosTurnKey = human2.key;

			human3.rack.empty();
			robot1.score = 1;
			human2.score = 2;
			human3.score = 3;

			let player = game.getPlayer();
			assert.equal(player.key, human2.key);
			player = game.getPlayer(human2.key);
			assert.equal(player.key, human2.key);
			assert.equal(game.nextPlayer().key, human3.key);
			assert.equal(game.previousPlayer().key, robot1.key);
			assert.equal(game.previousPlayer(robot1).key, human3.key);
			assert.equal(game.previousPlayer(human2.key).key, robot1.key);
			assert.equal(game.nextPlayer().key, human3.key);
			assert.equal(game.nextPlayer(robot1).key, human2.key);
			assert.equal(game.nextPlayer(human2.key).key, human3.key);
			assert.equal(game.winningScore(), 3);
			assert.equal(game.getPlayerWithNoTiles().key, human3.key);
			assert.equal(game.state, Game.STATE_WAITING);
			assert.equal(game.getPlayerWithNoTiles().key, human3.key);
			return game.simple(um);
		})
		.then(s => {
			assert.equal(s.key, game.key);
			assert.equal(s.creationTimestamp, game.creationTimestamp);
			assert.equal(s.edition, game.edition);
			assert.equal(s.dictionary, game.dictionary);
			assert.equal(s.predictScore, game.predictScore);
			assert.equal(s.wordCheck, game.wordCheck);
			assert.equal(s.allowTakeBack, game.allowTakeBack);
			assert.equal(s.state, game.state);
			assert.equal(s.turns, game.turns.length);
			assert.equal(s.whosTurnKey, game.whosTurnKey);
			assert.equal(s.timerType, game.timerType);
			assert.equal(s.timeLimit, game.timeLimit);
			assert.equal(s.timePenalty, game.timePenalty);
			assert.equal(s.pausedBy, game.pausedBy);
			assert.equal(s.minPlayers, game.minPlayers);
			assert.equal(s.maxPlayers, game.maxPlayers);
			assert.equal(s.penaltyType, game.penaltyType);
			assert.equal(s.penaltyPoints, game.penaltyPoints);
			assert.equal(s.nextGameKey, game.nextGameKey);
			assert.equal(s.lastActivity, game.lastActivity());
			assert.equal(s.players.length, 3);
			return Promise.all([
				robot1.simple(game, um),
				human2.simple(game, um),
				human3.simple(game, um)
			])
			.then(ps => {
				assert.deepEqual(s.players[0], ps[0]);
				assert.deepEqual(s.players[1], ps[1]);
				assert.deepEqual(s.players[2], ps[2]);
			});
		});
	});

	it("$html", () => {
		const p = {
			//debug: console.debug,
			edition:"English_Scrabble",
			dictionary:"Oxford_5000",
			timeLimit: 999,
			predictScore: false,
			allowTakeBack: false,
			noPlayerShuffle: true
		};

		const robot1 = new Player(
			{name:"Robot 1", key:"robot1", isRobot: true});
		const human1 = new Player(
			{name:"Human 1", key:"human1", isRobot: false});
		const human2 = new Player(
			{name:"Human 2", key:"human2", isRobot: false});
		const game = new Game(p);

		const socket = new TestSocket();

        return Platform.i18n().load("qqq")
		.then(() => game.create())
		.then(game => {
			game.addPlayer(human1);
			game.addPlayer(robot1);
			game.addPlayer(human2);
			game.whosTurnKey = human1.key;

			const $tab = $("<table></table>").addClass("player-table");
			let $tr;
			$tr = human1.$ui(human1, false);
			assert($tr.hasClass("whosTurn"));
			$tab.append($tr);
			$tr = robot1.$ui(human1, false);
			$tab.append($tr);
			assert(!$tr.hasClass("whosTurn"));
			$tr = human2.$ui(human1, false);
			$tab.append($tr);
			assert(!$tr.hasClass("whosTurn"));

			const $act = game.$ui(game.getPlayer());

			//console.debug(`expect: ${$tab.html()}`);
			//console.debug(`actual: ${$act.html()}`);
			assert($act[0].isEqualNode($tab[0]),
				   `expected: ${$tab.html()}\n actual: ${$act.html()}`);
		})
		.then(() => game.connect(socket, human1.key))
		.then(() => {
			game.whosTurnKey = human2.key;
			human1.missNextTurn = true;
			const $tab = $("<table></table>").addClass("player-table");
			let $tr;
			$tr = human1.$ui(human2, true);
			$tab.append($tr);
			assert(!$tr.hasClass("whosTurn"));
			$tr = robot1.$ui(human2, false);
			$tab.append($tr);
			assert(!$tr.hasClass("whosTurn"));
			$tr = human2.$ui(human2, false);
			assert($tr.hasClass("whosTurn"));
			$tab.append($tr);

			const $act = game.$ui(game.getPlayer());
			assert($act.find("#playerhuman1 td.player-name")
				   .hasClass("miss-turn"));
			//console.debug(`expect: ${$tab.html()}`);
			//console.debug(`actual: ${$act.html()}`);
			assert($act[0].isEqualNode($tab[0]),
				   `expected: ${$tab.html()}\n actual: ${$act.html()}`);
		});
	});

	it("last move in game", () => {
		const game = new Game({
			//debug: console.debug,
			edition:"Tiny",
			dictionary:"Oxford_5000",
			noPlayerShuffle: true
		});
		const human1 = new Player({
			name:"Human 1", key:"human1", isRobot: false});
		const human2 = new Player({
			name:"Human 2", key:"human2", isRobot: false});
		const move = new Move({
			placements: [
				new Tile({letter:"X", isBlank:false, score:1, col: 6, row: 7}),
				new Tile({letter:"W", isBlank:false, score:1, col: 7, row: 7}),
				new Tile({letter:"O", isBlank:false, score:1, col: 8, row: 7}),
				new Tile({letter:"R", isBlank:false, score:1, col: 9, row: 7}),
				new Tile({letter:"D", isBlank:false, score:1, col: 10, row: 7})
			],
			words: [ { word: "XWORD", score: 99 }],
			score: 99
		});
		const socket = new TestSocket();
		let turns = [
			{
				event: Notify.TURN,
				data: {
					type: Turn.PLAY,
					playerKey: human1.key,
					nextToGoKey: human2.key,
					score: move.score,
					words: move.words,
					placements: move.placements
				}
			}
		];
		const handle = (event, data) => {
			const turn = turns.shift();
			Assert.sparseEqual(
				{ event: event, data: data}, turn);
			if (turns.length === 0) {
				// Last play should have no replacements, so player rack
				// will now be empty.
				assert(!data.replacements);
				socket.done();
			}
		};
		socket.on(Notify.TURN, handle);
		socket.on(Notify.CONNECTIONS, () => {});
		socket.on("*", (event, data) => {
			console.error("UNEXPECTED EVENT", event);
			assert.fail(event);
		});
		return game.create()
		.then(game => {
			game.addPlayer(human1);
			human1.rack.empty();
			human1.rack.addTile(
				new Tile({letter:"W", isBlank:false, score:1}));
			human1.rack.addTile(
				new Tile({letter:"O", isBlank:false, score:1}));
			human1.rack.addTile(
				new Tile({letter:"R", isBlank:false, score:1}));
			human1.rack.addTile(
				new Tile({letter:"D", isBlank:false, score:1}));
			human1.rack.addTile(
				new Tile({letter:"X", isBlank:false, score:1}));
			game.addPlayer(human2);
			// Empty the bag
			game.letterBag.getRandomTiles(
				game.letterBag.remainingTileCount());
			game.whosTurnKey = human1.key;
			game.noPlayerShuffle = true;
		})
		.then(() => game.connect(socket, human1.key))
		.then(() => assert.equal(game.state, Game.STATE_PLAYING))
		.then(() => game.play(human1, move))
		.then(() => socket.wait())
		.then(() => {
			// Make sure play is finished
			assert(human1.rack.isEmpty());
			assert(!human2.rack.isEmpty());
		});
	});

	// Clear missed turn flag set after challenge failed
	it("clear missed turn", () => {
		const game = new Game({
			//debug: console.debug,
			edition:"Tiny",
			dictionary:"Oxford_5000",
			noPlayerShuffle: true
		});
		const human1 = new Player({
			name: "Human 1", key: "human1", isRobot: false});
		const human2 = new Player({
			name: "Human 2", key: "human2", isRobot: false});
		const human3 = new Player({
			name:"Human 3", key:"human3", isRobot: false});
		const socket = new TestSocket();
		socket.on(Notify.CONNECTIONS, () => {});
		socket.on("*", (event, data) => {
			if (event === Notify.TURN) {
				assert.equal(data.type, Turn.PASSED);
				socket.done();
				return;
			}
			console.error("UNEXPECTED EVENT", event);
			assert.fail(event);
		});
		return game.create()
		.then(game => {
			game.addPlayer(human1);
			game.addPlayer(human2);
			game.addPlayer(human3);
			human2.missNextTurn = true;
		})
		.then(() => game.connect(socket, human1.key))
		.then(() => {
			assert.equal(game.whosTurnKey, human1.key);
			assert(human2.missNextTurn);
		})
		.then(() => game.pass(human1, Turn.PASSED))
		.then(() => {
			assert.equal(game.whosTurnKey, human3.key);
			assert(!human3.missNextTurn);
		});
	});

	it("verify human play", () => {
		const game = new Game({
			//debug: console.debug,
			edition:"Tiny",
			dictionary:"Oxford_5000",
			noPlayerShuffle: true,
			wordCheck: Game.WORD_CHECK_REJECT
		});
		const human1 = new Player({
			name:"Human 1", key:"human1", isRobot: false});
		const human2 = new Player({
			name:"Human 2", key:"human2", isRobot: false});
		const move = new Move({
			placements: [
				new Tile({letter:"X", isBlank:false, score:1, col: 6, row: 7}),
				new Tile({letter:"Y", isBlank:false, score:1, col: 7, row: 7}),
				new Tile({letter:"Z", isBlank:false, score:1, col: 8, row: 7})
			],
			words: [ { word: "XYZ", score: 99 }],
			score: 99
		});
		const socket1 = new TestSocket();
		socket1.on(Notify.REJECT, (event, data) => {
			assert.deepEqual(data, {
				playerKey: human1.key,
				words: [ "XYZ" ] });
			socket1.done();
		});
		socket1.on(Notify.CONNECTIONS, () => {});
		socket1.on("*", (event, data) => {
			console.error("Socket 1 UNEXPECTED EVENT", event);
			assert.fail(event);
		});

		const socket2 = new TestSocket();
		socket2.on(Notify.CONNECTIONS, () => {});
		socket2.on("*", (event, data) => {
			console.error("Socket 2 UNEXPECTED EVENT", event);
			assert.fail(event);
		});

		return game.create()
		.then(game => {
			game.addPlayer(human1);
			human1.rack.empty();
			human1.rack.addTile(
				new Tile({letter:"X", isBlank:false, score:1}));
			human1.rack.addTile(
				new Tile({letter:"Y", isBlank:false, score:1}));
			human1.rack.addTile(
				new Tile({letter:"Z", isBlank:false, score:1}));

			game.addPlayer(human2);
		})
		.then(() => game.connect(socket1, human1.key))
		.then(() => game.connect(socket2, human2.key))
		.then(() => game.play(human1, move))
		.then(() => socket1.wait());
	});

	it("load from file", () => {
		const db = new Platform.Database("test", "game");
		return db.get("test_game", Game.classes)
		.then(game => game.onLoad(this.db))
		.then(game => {
			const human = game.getPlayer("human");
			return game.pass(human);
		});
	});

	it("anotherGame", () => {
		let game;
		const db = new Platform.Database("test", "game");
		return db.get("test_game", Game.classes)
		.then(g => game = g)
		.then(() => game.onLoad(this.db))
		.then(() => game.anotherGame("human"))
		.then(newgame => {
			assert.notEqual(game.key, newgame.key);
			return game.anotherGame("human")
			.catch(e => {
				assert.equal(e, "Next game already exists");
			});
		});
	});

	it("hint", () => {
		let game;
		const db = new Platform.Database("test", "game");
		return db.get("test_game", Game.classes)
		.then(g => game = g)
		.then(() => game.onLoad(this.db))
		.then(() => game.hint(game.getPlayer()))
		.then(() => {
			const p = game.getPlayer();
			p.rack.empty();
			return game.hint(game.getPlayer());
		});
	});

	it("advise", () => {
		let game;
		const db = new Platform.Database("test", "game");
		return db.get("test_game", Game.classes)
		.then(g => game = g)
		.then(() => game.onLoad(this.db))
		.then(() => game.anotherGame("human"))
		.then(() => game.toggleAdvice(game.getPlayer()))
		.then(() => game.advise(game.getPlayer(), 1));
	});
});

