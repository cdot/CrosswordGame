/* See README.md at the root of this distribution for copyright and
   license information */
/* eslint-env node, mocha */
/*global document:writable*/

/**
 * Unit tests for Board class
 */
describe("Board class", () => {
	const deps = [
		{ Board: "game/Board" },
		{ Edition: "game/Edition" },
		{ Tile: "game/Tile" },
		{ Square: "game/Square" }
	];

	const TS = require("./TestSupport.js");
	before(required => TS.depend(required, deps));

	it("construct", () => {
		return Edition.load("Tiny")
		.then(edition => {
			let b = new Board(edition);
			b.parse(
				"|Q| | | | | | | | | | | | | | |\n" +
				"|U| | | | | | | | | | | | | | |\n" +
				"|E| | | | | | | | | | | | | | |\n" +
				"|S|C|I|E|N|C|E| | | | | | | | |\n" +
				"|T| | | | | | | | | | | | | | |\n" +
				"|I| | | | | | | | | | | | | | |\n" +
				"|O|P|I|N|I|O|N| | | | | | | | |\n" +
				"|N| | | | | |O|M| | | | | | | |\n" +
				"| | | | | | | | | | | | | | | |\n" +
				"| | | | | | | | | | | | | | | |\n" +
				"| | | | | | | | | | | | | | | |\n" +
				"| | | | | | | | | | | | | | | |\n" +
				"| | | | | | | | | | | | | | | |\n" +
				"| | | | | | | | | | | | | | | |\n" +
				"| | | | | | | | | | | | | | | |\n", edition);
			b.at(6, 6).placeTile(null);
			b.at(6, 6).placeTile(new Tile({letter: "N", isBlank: true}), true);
			assert.equal(b,
						 "Board 11x11\n" +
						 "|Q| | | | | | | | | |8|\n" +
						 "|U|4| | | | | | | |4| |\n" +
						 "|E| |7| | | | | |7| | |\n" +
						 "|S|C|I|E|N|C|E|3| | | |\n" +
						 "|T| | | |2| |2| | | | |\n" +
						 "|I| | | | |6| | | | | |\n" +
						 "|O|P|I|N|I|O|n| | | | |\n" +
						 "|N| | |3| | |O|M| | | |\n" +
						 "| | |7| | | | | |7| | |\n" +
						 "| |4| | | | | | | |4| |\n" +
						 "|8| | | | | | | | | |8|\n");
			assert.equal(b.squaresUsed(), 22);
		});
	});

	it("touching old", () => {
		return Edition.load("Tiny")
		.then(edition => {
			let b = new Board(edition);
			for (let r = 0; r < b.rows; r++)
				for (let c = 0; c < b.cols; c++)
					assert(!b.touchingOld(r, c));
			const mr = Math.floor(b.rows / 2);
			const mc = Math.floor(b.cols / 2);
			let sq = b.at(mr, mc);
			let t = new Tile({letter: "?"});
			sq.placeTile(t, true);
			assert.equal(t.row, mr);
			assert.equal(t.col, mc);
			assert(sq.tileLocked);

			b.at(0, 0).placeTile(new Tile({letter: "t"}), true);
			b.at(0, b.rows-1).placeTile(new Tile({letter: "T"}), true);
			b.at(b.cols-1, 0).placeTile(new Tile({letter: "b"}), true);
			b.at(b.cols-1, b.rows-1).placeTile(new Tile({letter: "B"}), true);
			//console.log(b);
			for (let r = 0; r < b.rows; r++) {
				for (let c = 0; c < b.cols; c++) {
					if (r == mr && (c == mc-1 || c == mc+1)
						|| c == mc && (r == mr-1 || r == mr+1)
						|| r == 0 && (c == 1 || c == b.cols-2)
						|| c == 0 && (r == 1 || r == b.rows-2)
						|| r == b.rows - 1 && (c == 1 || c == b.cols - 2)
						|| c == b.cols - 1 && (r == 1 || r == b.cols - 2))
						assert(b.touchingOld(r, c), `${r} ${c}`);
					else
						assert(!b.touchingOld(r, c), `${r} ${c}`);
				}
			}
		});
	});

	it("analysePlay and scorePlay", () => {
		return Edition.load("Tiny")
		.then(edition => {
			let b = new Board(edition);
			for (let r = 0; r < b.rows; r++)
				for (let c = 0; c < b.cols; c++)
					assert(!b.touchingOld(r, c));
			const mr = Math.floor(b.rows / 2);
			const mc = Math.floor(b.cols / 2);
			
			const W = new Tile({letter: "W", score:4});
			const O = new Tile({letter: "O", score:1});
			const R = new Tile({letter: "R", score:2, isBlank:true});
			const D = new Tile({letter: "D", score:3});
			
			b.at(mr, mc).placeTile(W);
			b.at(mr, mc+1).placeTile(O);
			b.at(mr, mc+2).placeTile(R);
			b.at(mr, mc+3).placeTile(D);

			let move = b.analysePlay();
			TS.sparseEqual(move, {
				words: [ { word: "WORD", score: 20 } ],
				score: 35,
				placements: [ W, O, R, D ]
			});

			// Clear the temp tiles
			b.at(mr, mc).placeTile();
			b.at(mr, mc+1).placeTile();
			b.at(mr, mc+2).placeTile();
			b.at(mr, mc+3).placeTile();

			// Lock down the play
			b.at(mr, mc).placeTile(W, true);
			b.at(mr, mc+1).placeTile(O, true);
			b.at(mr, mc+2).placeTile(R, true);
			b.at(mr, mc+3).placeTile(D, true);

			// Score another play that extends the existing word
			const S = new Tile({letter: "S", score: 1});
			const U = new Tile({letter: "U", score: 1});
			const N = new Tile({letter: "N", isBlank:true, score: 2});

			b.at(mr, mc-1).placeTile(S);
			b.at(mr+1, mc-1).placeTile(U);
			b.at(mr+2, mc-1).placeTile(N);

			const words = [];
			const got = b.scorePlay(mc-1, mr+2, 1, 0, [ S, U, N ], words);
			assert.deepEqual(words, [ { word: "SWORD", score: 11 }, { word: "SUN", score: 5 } ]);
			assert.equal(got, 26);

			move = b.analysePlay();
			TS.sparseEqual(move, {
				words: [ { word: "SUN", score: 5 }, { word: "SWORD", score: 11 } ],
				score: 26,
				placements: [ S, U, N ]
			});

			// clear temp tiles
			b.at(mr, mc-1).placeTile();
			b.at(mr+1, mc-1).placeTile();
			b.at(mr+2, mc-1).placeTile();

			// Score another play that intersects the existing word
			b.at(mr+1, mc+3).placeTile(U);
			b.at(mr+2, mc+3).placeTile(N);

			const w2 = [];
			const g2 = b.scorePlay(mc+3, mr+2, 1, 0, [ D, U, N ], w2);
			assert.deepEqual(w2, [ { word: "DUN", score: 6 } ]);
			assert.equal(g2, 6);

			move = b.analysePlay();
			TS.sparseEqual(move, {
				words: [ { word: "DUN", score: 6 } ],
				score: 6,
				placements: [ U, N ]
			});
			
		});
	});

	it("analysePlay - disconnected", () => {
		return Edition.load("Tiny")
		.then(edition => {
			let b = new Board(edition);
			for (let r = 0; r < b.rows; r++)
				for (let c = 0; c < b.cols; c++)
					assert(!b.touchingOld(r, c));
			const mr = Math.floor(b.rows / 2);
			const mc = Math.floor(b.cols / 2);
			
			const W = new Tile({letter: "W", score:4});
			const O = new Tile({letter: "O", score:1});
			const R = new Tile({letter: "R", score:2, isBlank:true});
			const D = new Tile({letter: "D", score:3});
			
			b.at(mr, mc).placeTile(W);
			b.at(mr, mc+1).placeTile(O);
			b.at(mr, mc+2).placeTile(R);
			b.at(mr, mc+3).placeTile(D);

			let move = b.analysePlay();
			TS.sparseEqual(move, {
				words: [ { word: "WORD", score: 20 } ],
				score: 35,
				placements: [ W, O, R, D ]
			});

			// Clear the temp tiles
			b.at(mr, mc).placeTile();
			b.at(mr, mc+1).placeTile();
			b.at(mr, mc+2).placeTile();
			b.at(mr, mc+3).placeTile();

			// Lock down the play
			b.at(mr, mc).placeTile(W, true);
			b.at(mr, mc+1).placeTile(O, true);
			b.at(mr, mc+2).placeTile(R, true);
			b.at(mr, mc+3).placeTile(D, true);

			const S = new Tile({letter: "S", score: 1});

			b.at(1, 1).placeTile(S);

			move = b.analysePlay();
			assert.equal(move, "Disconnected placement");
		});
	});

	it("analyse first play - disconnected", () => {
		return Edition.load("Tiny")
		.then(edition => {
			let b = new Board(edition);
			for (let r = 0; r < b.rows; r++)
				for (let c = 0; c < b.cols; c++)
					assert(!b.touchingOld(r, c));
			const mr = Math.floor(b.rows / 2);
			const mc = Math.floor(b.cols / 2);
			
			const W = new Tile({letter: "W", score:4});
			const O = new Tile({letter: "O", score:1});
			const R = new Tile({letter: "R", score:2, isBlank:true});
			const D = new Tile({letter: "D", score:3});
			
			b.at(mr, mc).placeTile(W);
			b.at(mr, mc+1).placeTile(O);
			b.at(mr+1, mc+2).placeTile(R);
			b.at(mr, mc+3).placeTile(D);

			let move = b.analysePlay();
			assert.equal(move, "Disconnected placement");
		});
	});

	it("analyse first play - centre missing", () => {
		return Edition.load("Tiny")
		.then(edition => {
			let b = new Board(edition);
			for (let r = 0; r < b.rows; r++)
				for (let c = 0; c < b.cols; c++)
					assert(!b.touchingOld(r, c));
			const mr = Math.floor(b.rows / 2);
			const mc = Math.floor(b.cols / 2);
			
			const W = new Tile({letter: "W", score:4});
			const O = new Tile({letter: "O", score:1});
			const R = new Tile({letter: "R", score:2, isBlank:true});
			const D = new Tile({letter: "D", score:3});
			
			b.at(mr, mc+1).placeTile(W);
			b.at(mr, mc+2).placeTile(O);
			b.at(mr, mc+3).placeTile(R);
			b.at(mr, mc+4).placeTile(D);

			let move = b.analysePlay();
			assert.equal(move, "Centre must be used");
		});
	});

	it("analyse first play - single tile", () => {
		return Edition.load("Tiny")
		.then(edition => {
			let b = new Board(edition);
			for (let r = 0; r < b.rows; r++)
				for (let c = 0; c < b.cols; c++)
					assert(!b.touchingOld(r, c));
			const mr = Math.floor(b.rows / 2);
			const mc = Math.floor(b.cols / 2);
			
			const W = new Tile({letter: "W", score:4});
			const O = new Tile({letter: "O", score:1});
			const R = new Tile({letter: "R", score:2, isBlank:true});
			const D = new Tile({letter: " ", isBlank: true, score:3});
			
			b.at(mr, mc).placeTile(W);

			let move = b.analysePlay();
			assert.equal(move, "First word must be at least two tiles");
		});
	});

	it("$ui", () => {
		const edition = new Edition({
			layout: [
				"Dd_",
				"T_t",
				"QqM" ],
			bag: [
				{ score: 0, count: 1 },
				{ letter: "W", score: 1, count: 1 },
				{ letter: "O", score: 1, count: 1 },
				{ letter: "R", score: 1, count: 1 },
				{ letter: "D", score: 1, count: 1 },
				{ letter: "A", score: 1, count: 1 },
				{ letter: "L", score: 1, count: 1 },
				{ letter: "K", score: 1, count: 1 }
			],
			rackCount: 3,
			swapCount: 1,
			bonuses: {}
		});

		let b = new Board(edition);
		const W = new Tile({letter: "W", score:4});
		const O = new Tile({letter: "O", score:1});
		const R = new Tile({letter: "R", score:2, isBlank:true});
		const D = new Tile({letter: "D", score:3});
		const A = new Tile({letter: "A", score: 1});
		const L = new Tile({letter: "L", isBlank:true, score: 2});
		const K = new Tile({letter: "K", score: 5});
			
		// Lock down the play. This should not affect $ui!
		b.at(0, 0).placeTile(W, true);
		b.at(0, 1).placeTile(O, true);
		b.at(0, 2).placeTile(R, true);
		b.at(1, 0).placeTile(A);
		b.at(2, 0).placeTile(L);

		// Not going to bother with a detailed check because it's obvious
		// from the UI
		const s = b.$ui();
	});
});
