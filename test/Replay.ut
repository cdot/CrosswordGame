/* See README.md at the root of this distribution for copyright and
   license information */
/* eslint-env node, mocha */

/**
 * Unit tests for replaying a game.
 */

describe("Replay", () => {
	
	const TS = require("./TestSupport.js");
	before(required => TS.depend(required, {
		Tile: "game/Tile",
	  Replay: "game/Replay"
  }));

  function assertGameEqual(actual, expected, noTurns) {
    const elb = expected.letterBag;
    expected.letterBag = undefined;

    const alb = actual.letterBag;
    actual.letterBag = undefined;

    assert.deepEqual(alb.tiles.sort(Tile.cmp),
                     elb.tiles.sort(Tile.cmp));

    const racks = [];
    for (let i = 0; i < actual.players.length; i++) {
      let pa = actual.players[i];
      let pe = expected.getPlayerWithKey(pa.key);
      assert.deepEqual(pa.rack.letters().sort(),
                       pe.rack.letters().sort());
      console.log("Actual",pa.key,pa.score);
      console.log("Expect",pe.key,pe.score);
      assert.equal(pa.score, pe.score);
      racks.push({key: pa.key, pa: pa.rack, pe: pe.rack});
      pa.rack = undefined;
      pe.rack = undefined;
    }

    let eturns, aturns;
    if (noTurns) {
      eturns = expected.turns;
      aturns = actual.turns;
      expected.turns = undefined;
      actual.turns = undefined;
    }

    //assert.deepEqual(actual, expected);

    if (noTurns) {
      expected.turns = eturns;
      actual.turns = aturns;
    }

    expected.letterBag = elb;
    actual.letterBag = alb;

    for (let r of racks) {
      actual.getPlayer(r.key).rack = r.pa;
      expected.getPlayer(r.key).rack = r.pe;
    }
  }

  function UNit() {}

  // Script:
  // A swaps
  // B plays well
  // A challenges, fails
  // A plays well
  // A takes back
  // A plays badly
  // B challenges, wins
  // B passes
  // A passes
  // B passes
  // A passes
  // Should take us to game over
  it("replay", () => {
		const db = new Platform.Database("test", "game");
    let preGame, game, preBag = [];

    function checkBag(game) {
      const letters = [];
      for (const pl of game.players) {
        for (const l of pl.rack.letters())
          letters.push(l);
      }
      for (const bt of game.board.tiles())
        letters.push(bt.isBlank ? " " : bt.letter);
      for (const bl of game.letterBag.letters())
        letters.push(bl);
      assert.equal(
        letters.sort().join(""),
        preBag.sort().join(""));
    }
    
		return db.get("good_game", Replay.classes)
    .then(g => g.onLoad(db))
		.then(g => preGame = g)
    .then(() => {
      const game = new Replay(preGame);
      game.key = "simulated_game";
      game._debug = console.debug;
      return game.getEdition()
      .then(edo => {
        for (const l of edo.bag) {
          for (let i = 0; i < l.count; i++)
            preBag.push(l.letter);
        }
      })
      .then(() => game.create());
    })
    .then(game => game.onLoad(new Platform.Database("test/temp", "game")))
    .then(game => {
      let promise = Promise.resolve();
      for (let i = 0; i < game.playedGame.turns.length; i++)
        promise = promise.then(() => {
          checkBag(game);
          return game.step()
          .then(() => checkBag(game));
        });
      return promise
      .then(() => assertGameEqual(game, preGame));
    });
  });
  
  it("kolano", () => {
		const db = new Platform.Database("test", "game");
    let preGame, game, preBag = [];

    function checkBag(game) {
      const letters = [];
      for (const pl of game.players) {
        for (const l of pl.rack.letters())
          letters.push(l);
      }
      for (const bt of game.board.tiles())
        letters.push(bt.isBlank ? " " : bt.letter);
      for (const bl of game.letterBag.letters())
        letters.push(bl);
      assert.equal(
        letters.sort().join(""),
        preBag.sort().join(""));
    }
    
		return db.get("kolano", Replay.classes)
    .then(g => g.onLoad(db))
		.then(g => preGame = g)
    .then(() => {
      const game = new Replay(preGame);
      game.key = "simulated_game";
      game._debug = console.debug;
      return game.getEdition()
      .then(edo => {
        for (const l of edo.bag) {
          for (let i = 0; i < l.count; i++)
            preBag.push(l.letter);
        }
      })
      .then(() => game.create());
    })
    .then(game => game.onLoad(new Platform.Database("test/temp", "game")))
    .then(game => {
      let promise = Promise.resolve();
      for (let i = 0; i < game.playedGame.turns.length; i++)
        promise = promise.then(() => {
          checkBag(game);
          return game.step()
          .then(() => checkBag(game));
        });
      return promise
      .then(() => assertGameEqual(game, preGame));
    });
  });
});

