/* See README.md at the root of this distribution for copyright and
   license information */
/* eslint-env node, mocha */

requirejs = require("requirejs");

requirejs.config({
    baseUrl: `${__dirname}/..`,
	nodeRequire: require,
	paths: {
		common: "js/common",
		game: "js/game",
		dawg: "js/dawg",
		platform: "js/server/ServerPlatform"
	}
});

/**
 * Unit tests for Game commands that are issued during gameplay.
 */

describe("Game - human commands - tests", () => {

	const deps = [
		{ TestSocket: "test/TestSocket" },
		
		{ Tile: "game/Tile" },
		{ Player: "game/Player" },
		{ Game: "game/Game" },
		
		{ Move: "game/Move" },
		{ Turn: "game/Turn" },
		{ Command: "game/Command" },
		{ Notify: "game/Notify" }
	];
	
	const Assert = require("./Assert.js");
	before(required => Assert.depend(required, deps));

	it("swap", () => {
		const game = new Game({
			edition:"Tiny",
			dictionary:"Oxford_5000",
			//_debug: console.debug,
			noPlayerShuffle: true
		});
		const human1 = new Player({
			name: "Human 1", key: "human1", isRobot: false});
		const human2 = new Player({
			name: "Human 2", key: "human2", isRobot: false});
		const socket = new TestSocket();
		let turns = 0;
		const handle = (event, turn) => {
			switch (turns++) {
			case 0:
				assert.equal(turn.type, Turn.SWAP);
				assert(!turn.words);
				assert(!turn.placements);
				assert.deepEqual(turn.replacements.map(t=>t.letter).sort(),
							 ["P","Q","R"]);
				assert.equal(turn.score, 0);
				assert.equal(turn.bonus, 0);
				assert.equal(turn.playerKey, human1.key);
				assert.equal(turn.nextToGoKey, human2.key);
				socket.done();
				break;
			default:
				console.error("UNEXPECTED TURN", turn);
				assert.fail("UNEXPECTED TURN");
			}
		};
		socket.on(Notify.TURN, handle);
		socket.on(Notify.CONNECTIONS, () => {});
		socket.on("*", (event, data) => {
			console.error("UNEXPECTED EVENT", event);
			assert.fail(event);
		});

		return game.create()
		.then(game => {
			game.addPlayer(human1);
			human1.rack.empty();
			human1.rack.addTile(
				new Tile({letter:"A", score:1}));
			human1.rack.addTile(
				new Tile({letter:"B", score:1}));
			human1.rack.addTile(
				new Tile({letter:"C", score:1}));
			human1.rack.addTile(
				new Tile({letter:"D", score:1}));
			human1.rack.addTile(
				new Tile({letter:"E", score:1}));
			game.addPlayer(human2);

			// Leave 3 tiles in the bag - enough to swap
			game.letterBag.getRandomTiles(
				game.letterBag.remainingTileCount());
			game.letterBag.returnTile(
				new Tile({letter:"P", score:1}));
			game.letterBag.returnTile(
				new Tile({letter:"Q", score:1}));
			game.letterBag.returnTile(
				new Tile({letter:"R", score:1}));
		})
		.then(() => game.connect(socket, human1.key))
		.then(() => assert.equal(game.state, Game.STATE_PLAYING))
		.then(() => game.swap(
			human1, [
				new Tile({letter:"A", score:1}),
				new Tile({letter:"C", score:1}),
				new Tile({letter:"E", score:1})
			]))
		.then(g => {
			assert.strictEqual(g, game);
			assert.deepEqual(
				human1.rack.letters().sort(),
				["B", "D", "P", "Q", "R"]);
		})
		.then(() => socket.wait());
	});

	it("anotherGame", () => {
		const human1 = new Player({
			name: "Human 1", key: "human1", isRobot: false});
		const human2 = new Player({
			name: "Human 2", key: "human2", isRobot: false});

		const game = new Game({
			edition:"Tiny",
			dictionary:"Oxford_5000",
			//_debug: console.debug,
			noPlayerShuffle: true
		});
		const socket = new TestSocket();
		socket.on(Notify.NEXT_GAME, (event, info) => {
			//console.debug("anotherGame", info);
			assert.equal(info.gameKey, game.nextGameKey);
			socket.done();
		});
		socket.on(Notify.CONNECTIONS, () => {});
		socket.on("*", (event, data) => {
			console.error("UNEXPECTED EVENT", event);
			assert.fail(event);
		});
		return game.create()
		.then(game => {
			game.addPlayer(human1);
			game.addPlayer(human2);
		})
		.then(() => game.connect(socket, human1.key))
		.then(() => game.anotherGame())
		.then(newGame => {
			// no shuffle, so player should be reset to first
			// player
			assert.equal(newGame.whosTurnKey, human1.key);
			assert.equal(newGame.timerType, game.timerType);
			assert.equal(newGame.timeLimit, game.timeLimit);
			assert.equal(newGame.timePenalty, game.timePenalty);
			assert.equal(newGame.edition, game.edition);
			assert.equal(newGame.dictionary, game.dictionary);
			assert.equal(newGame.minutesToPlay, game.minutesToPlay);
			assert.equal(newGame.predictScore, game.predictScore);
			assert.equal(newGame.allowTakeBack, game.allowTakeBack);
			assert.equal(newGame.wordCheck, game.wordCheck);
			assert.equal(newGame.minPlayers, game.minPlayers);
			assert.equal(newGame.maxPlayers, game.maxPlayers);
		})
		.then(() => socket.wait());
	});

	it("pass", () => {
		const human1 = new Player({
			name: "Human 1", key: "human1", isRobot: false});
		const human2 = new Player({
			name: "Human 2", key: "human2", isRobot: false});

		const game = new Game({
			edition:"Tiny",
			dictionary:"Oxford_5000",
			//_debug: console.debug,
			noPlayerShuffle: true
		});
		const socket = new TestSocket();
		let turns = 0;
		const handle = (event, turn) => {
			switch (turns++) {
			case 0:
				assert.equal(turn.type, Turn.PASSED);
				assert(!turn.words);
				assert(!turn.placements);
				assert(!turn.replacements);
				assert.equal(turn.score, 0);
				assert.equal(turn.bonus, 0);
				assert.equal(turn.playerKey, human1.key);
				assert.equal(turn.nextToGoKey, human2.key);
				// Player1 rack should be unchanged
				socket.done();
				break;
			default:
				console.error("UNEXPECTED TURN", event, turn);
				assert.fail("UNEXPECTED TURN");				
			}
		};
		socket.on(Notify.TURN, handle);
		socket.on(Notify.CONNECTIONS, () => {});
		socket.on("*", (event, data) => {
			console.error("UNEXPECTED EVENT", event);
			assert.fail(event);
		});
		return game.create()
		.then(game => {
			game.addPlayer(human1);
			human1.rack.addTile(
				new Tile({letter:"S", score:1}));
			human1.rack.addTile(
				new Tile({letter:"I", score:1}));
			human1.rack.addTile(
				new Tile({letter:"N", score:1}));
			human1.rack.addTile(
				new Tile({letter:"K", score:1}));
			game.addPlayer(human2);
			game.whosTurnKey = human1.key;
		})
		.then(() => game.connect(socket, human1.key))
		.then(() => game.pass(human1))
		.then(g => assert.strictEqual(g, game))
		.then(() => socket.wait());
	});

	it("play", () => {
		const W = new Tile({letter:"W", score:1, col: 7, row: 7});
		const O = new Tile({letter:"O", score:1, col: 8, row: 7});
		const R = new Tile({letter:"R", score:1, col: 9, row: 7});
		const D = new Tile({letter:"D", score:1, col: 10, row: 7});
		const move = new Move({
			placements: [ W, O, R, D ],
			words: [ { word: "WORD", score: 99 }],
			score: 99
		});
		const human1 = new Player({
			name: "Human 1", key: "human1", isRobot: false});
		const human2 = new Player({
			name: "Human 2", key: "human2", isRobot: false});
		const aTile = new Tile({letter:"A", score:1 });

		const game = new Game({
			edition:"Tiny",
			dictionary:"Oxford_5000",
			//_debug: console.debug,
			noPlayerShuffle: true
		});
		const socket = new TestSocket();
		let turns = 0;
		const handle = (event, turn) => {
			switch (turns++) {
			case 0:
				assert.equal(turn.type, Turn.PLAY);
				assert.equal(turn.playerKey, human1.key);
				assert.equal(turn.nextToGoKey, human2.key);
				assert.equal(turn.score, move.score);
				assert.deepEqual(turn.words, move.words);
				assert.deepEqual(turn.placements, move.placements);
				Assert.sparseEqual(turn.replacements, [ aTile ]);
				socket.done();
				break;
			default:
				console.error("UNEXPECTED TURN", event, turn);
				assert.fail("UNEXPECTED TURN");
			}
		};
		socket.on(Notify.TURN, handle);
		socket.on(Notify.CONNECTIONS, () => {});
		socket.on("*", (event, data) => {
			console.error("UNEXPECTED EVENT", event);
			assert.fail(event);
		});
		return game.create()
		.then(game => {
			game.addPlayer(human1);
			human1.rack.empty();
			human1.rack.addTile(
				new Tile({letter:"W", score:1}));
			human1.rack.addTile(
				new Tile({letter:"O", score:1}));
			human1.rack.addTile(
				new Tile({letter:"R", score:1}));
			human1.rack.addTile(
				new Tile({letter:"D", score:1}));
			human1.rack.addTile(
				new Tile({letter:"X", score:1}));
			game.addPlayer(human2);

			// Empty the letter bag, put an "A" in, not enough to
			// refill the rack
			game.letterBag.getRandomTiles(
				game.letterBag.remainingTileCount());
			game.letterBag.returnTile(aTile);
			game.whosTurnKey = human1.key;
		})
		.then(() => game.connect(socket, human1.key))
		.then(() => game.play(human1, move))
		.then(g => assert.strictEqual(g, game))
		.then(() => socket.wait())
		.then(() => assert.equal(game.whosTurnKey, human2.key));
	});

	it("game_over", () => {
		const game =  new Game({
			edition:"Tiny",
			dictionary:"Oxford_5000",
			//_debug: console.debug,
			noPlayerShuffle: true
		});
		const human1 = new Player({
			name:"Human1", key:"human1", isRobot: false});
		const human2 = new Player({
			name:"Human2", key:"human2", isRobot: false});
		const socket = new TestSocket();
		const handle = (event, turn) => {
			assert.equal(event, Notify.TURN);
			assert.equal(turn.type, Turn.GAME_OVER);
			const exp = {};
			exp[human1.key] = { tiles: -3 };
			exp[human2.key] = { tiles: 3 };
			assert.deepEqual(turn.score, exp);
			assert.equal(turn.playerKey, human1.key);
			assert.equal(turn.emptyPlayerKey, human2.key);
			assert(!turn.nextToGoKey);
			socket.done();
		};
		socket.on(Notify.TURN, handle);
		socket.on(Notify.CONNECTIONS, () => {});
		socket.on("*", (event, data) => {
			console.error("UNEXPECTED EVENT", event);
			assert.fail(event);
		});
		return game.create()
		.then(game => {
			game.addPlayer(human1);
			human1.rack.empty();
			human1.rack.addTile(
				new Tile({letter:"X", score:1}));
			human1.rack.addTile(
				new Tile({letter:"Y", score:1}));
			human1.rack.addTile(
				new Tile({letter:"Z", score:1}));
			game.addPlayer(human2);
			human2.rack.empty();
			// Empty the bag
			game.letterBag.getRandomTiles(
				game.letterBag.remainingTileCount());
			game.whosTurnKey = human1.key;
		})
		.then(() => game.connect(socket, human1.key))
		.then(() => game.confirmGameOver())
		.then(() => {
		});
	});

	it("take_back", () => {
		const game = new Game({
			edition:"Tiny",
			dictionary:"Oxford_5000",
			//_debug: console.debug,
			noPlayerShuffle: true
		});
		const human1 = new Player({
			name: "Human 1", key: "human1", isRobot: false});
		const human2 = new Player({
			name: "Human 2", key: "human2", isRobot: false});
		const move = new Move({
			placements: [
				new Tile({letter:"X", score:1, col: 7, row: 7}),
				new Tile({letter:"Y", score:1, col: 8, row: 7}),
				new Tile({letter:"Z", score:1, col: 10, row: 7})
			],
			words: [ { word: "XYZ", score: 3 }],
			score: 3
		});
		const socket = new TestSocket();
		socket.on(Notify.CONNECTIONS, () => {});
		let turns = 0;
		socket.on(Notify.TURN, (event, turn) => {
			switch (turns++) {
			case 0:
				assert.equal(turn.type, Turn.PLAY);
				Assert.sparseEqual(turn, move);
				break;
			case 1:
				assert.equal(turn.type, Turn.TOOK_BACK);
				assert.equal(turn.playerKey, human1.key);
				assert.equal(turn.nextToGoKey, human1.key);
				assert.equal(turn.score, -3);
				socket.done();
				break;
			default:
				console.error("UNEXPECTED TURN", event, turn);
				assert.fail(turn.type);
			}
		});
		socket.on("*", (event, turn) => {
			console.error("UNEXPECTED EVENT", event);
			assert.fail(event);
		});
		return game.create()
		.then(() => {
			game.addPlayer(human1);
			human1.rack.empty();
			human1.rack.addTile(
				new Tile({letter:"X", score:1}));
			human1.rack.addTile(
				new Tile({letter:"Y", score:1}));
			human1.rack.addTile(
				new Tile({letter:"Z", score:1}));
			human1.rack.addTile(
				new Tile({letter:"P", score:1}));
			human1.rack.addTile(
				new Tile({letter:"Q", score:1}));
			game.addPlayer(human2);

			// Empty the bag, then put some recognisable tiles in it
			// Empty the letter bag, put an "A" in, not enough to
			// refill the rack
			game.letterBag.getRandomTiles(
				game.letterBag.remainingTileCount());
			game.letterBag.returnTile(
				new Tile({letter:"A", score:1}));
			game.letterBag.returnTile(
				new Tile({letter:"B", score:1}));
			game.letterBag.returnTile(
				new Tile({letter:"C", score:1}));
		})
		.then(() => game.connect(socket, human1.key))
		.then(() => game.play(human1, move))
		.then(() => {
			assert.deepEqual(human1.rack.letters().sort(),
							 [ "A", "B", "C", "P", "Q" ]);
			assert(game.letterBag.isEmpty());
			
		})
		// Player 0 takes their move back, tils should return to the bag
		.then(() => game.takeBack(human1, Turn.TOOK_BACK))
		.then(g => {
			assert.strictEqual(g, game);
			assert.deepEqual(game.letterBag.letters().sort(),
							 [ "A", "B", "C" ]);
			// human1"s rack should be XYZPQ
			assert.deepEqual(human1.rack.letters().sort(),
							 [ "P", "Q", "X", "Y", "Z" ]);
		})
		.then(() => {
			assert.equal(game.whosTurnKey, human1.key);
		});
	});

	it("challenge", () => {
		// more tests are in Challenges.ut
		const game = new Game({
			edition:"Tiny",
			dictionary:"Oxford_5000",
			//_debug: console.debug,
			noPlayerShuffle: true
		});
		const human1 = new Player({
			name: "Human 1", key: "human1", isRobot: false});
		const human2 = new Player({
			name: "Human 2", key: "human2", isRobot: false});
		const socket = new TestSocket();
		socket.on(Notify.CONNECTIONS, () => {});
		socket.on("*", (event, data) => {
			if (event === Notify.TURN) {
				socket.done();
				return;
			}
			console.error("UNEXPECTED EVENT", event);
			assert.fail(event);
		});
		return game.create()
		.then(() => {
			game.addPlayer(human1);
			game.addPlayer(human2);
			game.whosTurnKey = human1.key;
		})
		.then(() => game.connect(socket, human1.key))
		.then(() => game.challenge(human1))
		.then(g => assert.strictEqual(g, game))
		.then(() => socket.wait())
		.then(() => assert.fail("Expected an error"))
		.catch(e => {
			assert.equal(e, "No previous move to challenge");
		});
	});
	
	it("pause", () => {
		const game = new Game({
			edition:"Tiny",
			dictionary:"Oxford_5000",
			//_debug: console.debug,
			noPlayerShuffle: true
		});
		const human1 = new Player({
			name: "Human 1", key: "human1", isRobot: false});
		const human2 = new Player({
			name: "Human 2", key: "human2", isRobot: false});
		const socket = new TestSocket();
		socket.on(Notify.CONNECTIONS, () => {});
		let ev = 0;
		socket.on("*", (event, data) => {
			//console.debug(event, data);
			switch (ev++) {
			case 0:
				assert.equal(event, Notify.PAUSE);
				assert.equal(data.key, game.key);
				assert.equal(data.name, human1.name);
				break;
			case 1:
				assert.equal(event, Notify.UNPAUSE);
				assert.equal(data.key, game.key);
				assert.equal(data.name, human2.name);
				socket.done();
				break;
			default:
				assert.fail("UNEXPECTED EVENT", event);
			}
		});
		return game.create()
		.then(() => {
			game.addPlayer(human1);
			game.addPlayer(human2);
			game.whosTurnKey = human1.key;
		})
		.then(() => game.connect(socket, human1.key))
		.then(() => game.pause(human1))
		.then(g => assert.strictEqual(g, game))
		.then(() => game.pause(human2))
		.then(g => assert.equal(g.pausedBy, human1.name))
		.then(() => game.unpause(human2))
		.then(g => assert.strictEqual(g, game))
		.then(g => assert(!game.pausedBy));
	});
});

