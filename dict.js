/* eslint-env node */

/**
 * Command-line program to explore the words encoded in a DAWG generated by DAWG_Compare.c
 */
const requirejs = require('requirejs');

requirejs.config({
	baseUrl: __dirname,
    nodeRequire: require,
	paths: {
		game: "js/game",
		dawg: "js/dawg",
		platform: "js/server"
	}
});

const DESCRIPTION = "USAGE\n  node dict.js [options] <dictionary> <words>\n"
+ "Explore a DAWG dictionary."

requirejs(["node-getopt", "platform/Platform", "dawg/Dictionary"], (Getopt, Platform, Dictionary) => {

	let biglist = {};
	
	function eachRoot(opt, root, dict) {
		if (opt.options.list) {
			if (root.node.child) {
				let list = [];
				console.log(`-- ${root.word} --`);
				biglist[root.word] = true;
				root.node.child.eachWord(root.word, w => list.push(w));
				
				list = list.filter(w => !biglist[w]);
				list.forEach(w => biglist[w] = true);
				
				console.log(list.join("\n"));
			}
		}
		else if (opt.options.anagrams) {
			console.log(`\nAnagrams of "${root.word}"`);
			let anag = dict.findAnagrams(root.word);
			console.log(anag);
		} else if (root.node && root.node.isEndOfWord)
			console.log(`'${root.word}' was found`,
						root.node.child ? "& is a root" : "");
		else if (root.node && root.node.child)
			console.log(`'${root.word}' is a root`);
		else
			console.log(`'${root.word}' NOT FOUND`);
	}
	
	function checkSequence(word, dict) {
		if (dict.hasSequence(word))
			console.log(`'${word}' is a valid sequence`);
		else
			console.log(`'${word}' is NOT a valid sequence`);
	}
	
	function withDictionary(opt, words) {
		console.log(`Loading dictionary from ${opt.dawgfile}`);
		Dictionary.load(opt.dawgfile)
		.then(dict => {
			if (opt.options.sequence)
				for (let w of words)
					checkSequence(w, dict);
			else {
				let roots = [];

				if (words.length === 0) {
					let letter = dict.root.child;
					while (letter) {
						roots.push({ word: letter.letter, node: dict.root });
						letter = letter.next;
					}
				} else {
					for (let w of words) {
						const word = w.toUpperCase();
						const node = dict.match(word);
						if (node)
							roots.push({ word: word, node: node });
					}
					roots.sort((a, b) => {
						return a.word.length > b.word.length ? -1 :
						a.word.length === b.word.length ? 0 : 1
					});
				}

				for (let root of roots)
					eachRoot(opt, root, dict);
			}
		});
	}

	let opt = Getopt.create([
        ["h", "help", "Show this help"],
		["l", "list", "Without paramaters, dump a complete list of the words in the DAWG. With parameters, dump all words that have the parameters word(s) as their root"],
		["f", "file=ARG", "Check all words read from file"],
		["a", "anagrams", "Find anagrams of the words and any sub-words"],
		["s", "sequence", "Determine if the strings passed are valid sub-sequences of any word in the dictionary e.g. 'UZZL' is a valid sub-sequence in an English dictionary as it is found in 'PUZZLE', but 'UZZZL' isn't"]
	])
        .bindHelp()
        .setHelp(`${DESCRIPTION}\nOPTIONS\n[[OPTIONS]]`)
		.parseSystem();

    if (opt.argv.length == 0) {
        opt.showHelp();
        throw "No DAWG filename given";
    } else {
		opt.dawgfile = opt.argv.shift();
	}

	if (opt.options.file) {
		Platform.getResource(opt.options.file)
		.then(data => {
			let words = data.toString().split(/\s+/);
			console.log(`Checking ${words.length} words`);
			withDictionary(opt, words);
		});
		
	}
	else
		withDictionary(opt, opt.argv);
	
});
