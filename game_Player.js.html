<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: game/Player.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: game/Player.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* See README.md at the root of this distribution for copyright and
   license information */
/* eslint-env amd, jquery */

define('game/Player', [
	'platform', 'game/GenKey', 'game/Rack',
], (
	Platform, GenKey, Rack
) => {

	// Unicode characters
	const BLACK_CIRCLE = '\u25cf';

	/**
	 * A player in a {@link Game}. Player objects are specific to
	 * a single game, and are used on both browser and server sides.
	 */
	class Player {

		/**
		 * @param {(string|Player)} name name of the player, or
		 * a Player object to copy
		 * @param {boolean} key unique key identifying the player. Names
		 * may be duplicated, but keys never are.
		 * @param {boolean} isRobot if name is a string and true then
		 * it's a robot. If name is a Player object, ignored.
		 */
		constructor(name, key, isRobot) {
			if (name instanceof Player) {
				// Copying an existing player
				this.isRobot = name.isRobot;
				this.key = name.key; // re-use
				name = name.name;
			} else {
				this.key = key;
				this.isRobot = isRobot;
			}

			/**
			 * Player name
			 * @member {string}
			 */
			this.name = name;

			/**
			 * Player doesn't have a rack until they join a game, as
			 * it's only then we know how big it has to be.
			 * @member {Rack}
			 */
			this.rack = null;

			/**
			 * Number of times this player has passed (or swapped)
			 * @member {number}
			 */
			this.passes = 0;

			/**
			 * Set true to advise player of better plays than the one
			 * they used
			 * @member {boolean}
			 */
			this.wantsAdvice = false;

			/**
			 * Player's current score
			 * @member {number}
			 */
			this.score = 0;

			/**
			 * Seconds remaining before play times out
			 * @member {number}
			 */
			this.timeRemaining = 0;

			/**
			 * We don't keep a pointer to the dictionary objects so we can
			 * cheaply serialise and send to the games interface. We just
			 * keep the name of the relevant object. This dictionary will
			 * only be used for findBestPlay for robot players.
			 * @member {string}
			 */
			this.dictionary = undefined;
		}

		/**
		 * Create simple structure describing a subset of the player
		 * state, for sending to the 'games' interface
		 * @param {Game} game the game the player is participating in
		 * @param {UserManager} um user manager for getting emails
		 * @return {Promise} resolving to a simple structure describing the player
		 */
		catalogue(game, um) {
			return (this.isRobot ? Promise.resolve({}) : um.getUser({key: this.key}))
			.then(ump => {
				return {
					name: this.name,
					isRobot: this.isRobot,
					connected: this.isRobot || (game.getConnection(this) !== null),
					dictionary: this.dictionary,
					key: this.key,
					score: this.score,
					email: ump.email ? true : false,
					timeRemaining: this.timeRemaining
				};
			})
			.catch(e => {
				// User key not found in the db, for some reason. Not fatal.
				return {
					isRobot: this.isRobot,
					connected: this.isRobot || (game.getConnection(this) !== null),
					key: this.key,
					score: this.score,
					timeRemaining: this.timeRemaining
				};
			});
		}

		/**
		 * Draw an initial rack from the letter bag.
		 * @param {LetterBag} letterBag LetterBag to draw tiles from
		 * @param {number} rackSize size of the rack
		 */
		fillRack(letterBag, rackSize) {
			// +1 to allow space for tile sorting in the UI
			this.rack = new Rack(rackSize + 1);
			for (let i = 0; i &lt; rackSize; i++)
				this.rack.addTile(letterBag.getRandomTile());
			this.score = 0;
		}

		/**
		 * Return all tiles to the letter bag
		 */
		returnTiles(letterBag) {
			for (let tile of this.rack.tiles())
				letterBag.returnTile(this.rack.removeTile(tile));
		}

		/**
		 * Set a play timeout for the player if they haven't player before
		 * time has elapsed
		 * @param {number} time number of seconds before elapse, or
		 * 0 for no timeout.
		 * If undefined, will restart a timer by stopTimer.
		 * @param {function} onTimeout a function() invoked if the
		 * timer expires
		 */
		startTimer(time, onTimeout) {
			if (typeof time !== 'undefined') {
				this.stopTimer();
				// Timer is being reset
				if (time === 0)
					// No timeout, nothing to do
					return;
				this._onTimeout = onTimeout;
			} else if (!this._timeoutTimer &amp;&amp; this.timeRemaining > 0) {
				// Timer was stopped in stopTimer with time remaining
				time = this.timeRemaining;
			} else {
				this.stopTimer();
				return;
			}

			console.log(`${this.name}'s go will time out in ${time}s at ${new Date(Date.now() + time * 1000)}`);

			// Set an overriding timeout
			this.timeRemaining = time;
			this._timeoutAt = Date.now() + time * 1000;
			this._timeoutTimer = setTimeout(() => {
				this._timeoutTimer = null;
				console.log(`${this.name} has timed out at ${Date.now()}`);
				// Invoke the timeout function
				this._onTimeout();
			}, time * 1000);
		}

		/**
		 * Cancel current timeout
		 */
		stopTimer() {
			if (this._timeoutTimer) {
				this.timeRemaining = (this._timeoutAt - Date.now()) / 1000;
				console.log(`${this.name} stopped timer with ${this.timeRemaining}s remaining`);
				clearTimeout(this._timeoutTimer);
				this._timeoutTimer = null;
			}
		}

		/**
		 * Generate a simple string representation of the player
		 */
		toString() {
			let s = `Player '${this.name}'`;
			if (this.isRobot)
				s += ' (Robot)';
			if (this.key)
				s += ` key ${this.key}`;
			return s;
		}

		/**
		 * Toggle wantsAdvice on/off
		 */
		toggleAdvice() {
			this.wantsAdvice = !this.wantsAdvice;
		}

		/**
		 * Promise to send an email invitation to a player on
		 * the server side only.
		 * @param {string} subject the subject of the mail
		 * @param {string} gameURL the URL of the game
		 * @param {object} config the global config object
		 * @param {UserManager} um user manager for getting emails
		 * @param {string} senderKey user key  for the sender, will default to
		 ( config.email.sender if undefined
		 * @return {Promise} Promise that resolves to the player's name
		 */
		emailInvitation(subject, gameURL, config, um, senderKey) {
			if (!config.mail || !config.mail.transport)
				return Promise.reject('Mail is not configured');
			const url = `${gameURL}/${this.key}`;
			return new Promise(
				resolve =>
				um.getUser({key: senderKey})
				.then(sender => resolve(`${sender.name}&lt;${sender.email}>`))
				.catch(e => resolve(config.email.sender)))
			.then(sender => {
				return um.getUser({key: this.key})
				.then(ump => {
					if (!ump.email)
						return Promise.reject();

					console.log(`Sending invitation to ${this.name}&lt;${ump.email}> subject ${subject} from ${sender} url ${url}`);
					return ump.email;
				})
				.then(email => config.mail.transport.sendMail({
					from: sender,
					to:  email,
					subject: subject,
					text: Platform.i18n('email-join-text', url),
					html: Platform.i18n('email-join-html', url)
				}))
				.then(() => this.name);
			});
		}

		/**
		 * Create score table representation of the player on the browser
		 * side only. This is intended to work both on a full Player
		 * object, but also on a Player.catalogue of the player.
		 * @param {Player} player the player (or player.catalogue) who's
		 * row this is
		 * @param {string} curKey the key of the player for whom the DOM is
		 * being generated
		 * @return {jQuery} DOM object for the score table
		 */
		createScoreDOM(curKey) {
			const $tr = $(`&lt;tr class="playerRow" id='player${this.key}'>&lt;/tr>`);
			$tr.append(`&lt;td class='turnPointer'>&amp;#10148;&lt;/td>`);
			const $icon = $('&lt;div class="ui-icon">&lt;/div>');
			$icon.addClass(this.isRobot ? "icon-robot" : "icon-person");
			$tr.append($("&lt;td>&lt;/td>").append($icon));
			const who = this.key === curKey
				? Platform.i18n('You')
				: this.name;
			$tr.append(`&lt;td class='playerName'>${who}&lt;/td>`);
			$tr.append('&lt;td class="remainingTiles">&lt;/td>');

			/**
			 * Jquery object that contains this player's online status on
			 * the browser side only.
			 * @private
			 * @member {jQuery}
			 */
			this.$status = $(`&lt;td class='connectState'>${BLACK_CIRCLE}&lt;/td>`);
			$tr.append(this.$status);
			this.$status.addClass(this.connected ? "online" : "offline");
			
			/**
			 * Jquery object that contains this player's score on
			 * the browser side only.
			 * @private
			 * @member {jQuery}
			 */
			this.$score = $(`&lt;td class='playerScore'>${this.score}&lt;/td>`);
			$tr.append(this.$score);
			return $tr;
		}

		/**
		 * Refresh score table representation of the player on the browser
		 * side only.
		 */
		refreshDOM() {
			this.$score.text(this.score);
		}

		/**
		 * Set 'online' status of player in UI on the browser
		 * side only.
		 * @param {boolean} tf true/false
		 */
		online(tf) {
			if (tf)
				this.$status.removeClass('offline').addClass('online');
			else
				this.$status.removeClass('online').addClass('offline');
		}
	}

	return Player;
});
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-dawg_compressor.html">dawg/compressor</a></li><li><a href="module-dawg_explore.html">dawg/explore</a></li><li><a href="module-design_valett.html">design/valett</a></li><li><a href="module-game_findBestPlay.html">game/findBestPlay</a></li><li><a href="module-i18n_checkTranslation.html">i18n/checkTranslation</a></li></ul><h3>Classes</h3><ul><li><a href="Board.html">Board</a></li><li><a href="BrowserPlatform.html">BrowserPlatform</a></li><li><a href="Database.html">Database</a></li><li><a href="Dialog.html">Dialog</a></li><li><a href="Dictionary.html">Dictionary</a></li><li><a href="Edition.html">Edition</a></li><li><a href="FileDatabase.html">FileDatabase</a></li><li><a href="Fridge.html">Fridge</a></li><li><a href="Game.html">Game</a></li><li><a href="I18N.html">I18N</a></li><li><a href="LetterBag.html">LetterBag</a></li><li><a href="Move.html">Move</a></li><li><a href="Platform.html">Platform</a></li><li><a href="Player.html">Player</a></li><li><a href="Rack.html">Rack</a></li><li><a href="Server.html">Server</a></li><li><a href="ServerPlatform.html">ServerPlatform</a></li><li><a href="Square.html">Square</a></li><li><a href="Surface.html">Surface</a></li><li><a href="Tile.html">Tile</a></li><li><a href="Trie.html">Trie</a></li><li><a href="TrieNode.html">TrieNode</a></li><li><a href="Turn.html">Turn</a></li><li><a href="Ui.html">Ui</a></li><li><a href="UserManager.html">UserManager</a></li><li><a href="XanadoPass.html">XanadoPass</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.7</a> on Thu Mar 10 2022 20:12:43 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
