<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: standalone/StandaloneGameUI.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: standalone/StandaloneGameUI.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*Copyright (C) 2022 The Xanado Project https://github.com/cdot/Xanado
  License MIT. See README.md at the root of this distribution for full copyright
  and license information. Author Crawford Currie http://c-dot.co.uk*/
/* eslint-env browser, jquery */

define([
  "common/Utils", "common/Channel",
  "common/CBOREncoder", "common/CBORDecoder", "common/Tagger",
  "dawg/Dictionary",
  "backend/BackendGame",
  "browser/BrowserGame",
  "browser/UI", "browser/GameUIMixin", "browser/Dialog",
  "standalone/StandaloneUIMixin",
  "touch-punch"
], (
  Utils, Channel,
  CBOREncoder, CBORDecoder, Tagger,
  Dictionary,
  BackendGame,
  BrowserGame,
  UI, GameUIMixin, Dialog,
  StandaloneUIMixin
) => {

  /**
   * Game that runs solely in the browser (no server).
   * To keep the codebase consistent with the client-server model, we
   * have two copies of the game; one is the "client side" (the front end)
   * version, while the other is the "server" version (the back end).
   */
  class StandaloneGameUI extends StandaloneUIMixin(GameUIMixin(UI)) {

    constructor() {
      super();

      /**
       * Game on the "server" side
       */
      this.backEndGame = undefined;

      /**
       * Game on the "client" side
       */
      this.frontEndGame = undefined;
    }

    /**
     * @implements browser/GameUIMixin#sendCommand
     */
    sendCommand(command, args) {
      const bePlayer = this.backEndGame.getPlayerWithKey(
        this.player.key);
      this.backEndGame.dispatchCommand(command, bePlayer, args);
    }

    /**
     * @implements browser/GameUIMixin#action_anotherGame
     */
    action_anotherGame() {
      this.backEndGame.anotherGame()
      .then(nextGame => {
        this.backEndGame.nextGameKey =
        this.frontEndGame.nextGameKey = nextGame.key;
        this.setAction("action_nextGame", $.i18n("Next game"));
        this.enableTurnButton(true);
      })
      .catch(assert.fail);
    }

    /**
     * @implements browser/GameUIMixin#action_nextGame
     */
    action_nextGame() {
      this.redirectToGame(this.backEndGame.nextGameKey);
    }

    /**
     * Create and run the game.
     */
    create() {

      super.create();

      const player_key = this.session.key;

      const fe = new Channel();
      const be = new Channel();
      // Cross-couple the channels
      fe.receiver = be;
      be.receiver = fe;

      be.on(
        BackendGame.Notify.MESSAGE,
        message => {
          // Chat message
          const mess = message.text.split(/\s+/);
          const verb = mess[0];

          switch (verb) {
          case "autoplay":
            // Tell *everyone else* that they asked for a hint
            be.game.autoplay();
            break;
          case "hint":
            be.game.hint(be.player);
            break;
          case "advise":
            be.game.toggleAdvice(be.player);
            break;
          case "allow":
            be.game.allow(be.player, mess[1]);
            break;
          default:
            be.game.notifyAll(BackendGame.Notify.MESSAGE, message);
          }
        });

      this.channel = fe;

      this.getGameDefaults()
      .then(() => this.initTheme())
      .then(() => this.initLocale())
      .then(() => {

        // Load the server game from localStorage, or create a new
        // game from defaults if there isn't one there.
        if (this.args.game) {
          console.debug(`Loading game ${this.args.game} from local storage`);
          return this.db.get(this.args.game, BackendGame)
          .then(game => {
            this.backEndGame = game;
            this.backEndGame._debug = this.args.debug
            ? console.debug : () => {};
            return game.onLoad(this.db);
          });

        } else {
          console.debug("Constructing new game");
          const setup = $.extend({}, StandaloneUIMixin.DEFAULTS);
          setup._debug = this.args.debug ? console.debug : () => {};
          return this.createGame(setup)
          .then(game => this.backEndGame = game);
        }
      })
      .then(() => {
        this.attachChannelHandlers();

        // Make a browser copy of the game
        const tagger = new Tagger(BrowserGame);
        this.frontEndGame =
        new CBORDecoder(tagger).decode(
          new CBOREncoder(tagger).encode(this.backEndGame, tagger), tagger);

        // Fix the player
        this.player
        = this.frontEndGame.player
        = this.frontEndGame.getPlayerWithKey(player_key);
      })
      .then(() => this.createUI(this.frontEndGame))
      .then(() => {
        $("#gameSetupButton")
        .on("click", () => {
          Dialog.open("browser/GameSetupDialog", {
            html: "standalone_GameSetupDialog",
            ui: this,
            game: this.backEndGame,
            onSubmit: (dlg, vals) => {
              for (const key of Object.keys(vals))
                this.backEndGame[key] = vals[key];
              this.backEndGame.save();
              this.redirectToGame(this.backEndGame.key);
            },
            error: e => this.alert(e, $.i18n("failed", $.i18n("Game setup")))
          });
        });
        $("#libraryButton")
        .on("click", () => {
          const parts = Utils.parseURLArguments(window.location.toString());
          parts._URL = parts._URL.replace(
            /standalone_game\./, "standalone_games.");
          window.location = Utils.makeURL(parts);
        });
      })
      .then(() => this.attachUIEventHandlers())
      // Tell the backend what channel to use to send and receive
      // notifications
      .then(() => this.backEndGame.connect(be, player_key))
      .catch(e => this.alert(e))
      .then(() => {
        $(".loading").hide();
        $(".waiting").removeClass("waiting");
      });
    }
  }

  new StandaloneGameUI().create();
});
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="BackendGame.html">BackendGame</a></li><li><a href="Board.html">Board</a></li><li><a href="BrowserBoard.html">BrowserBoard</a></li><li><a href="BrowserDatabase.html">BrowserDatabase</a></li><li><a href="BrowserGame.html">BrowserGame</a></li><li><a href="BrowserPlatform.html">BrowserPlatform</a></li><li><a href="BrowserPlayer.html">BrowserPlayer</a></li><li><a href="BrowserRack.html">BrowserRack</a></li><li><a href="BrowserTile.html">BrowserTile</a></li><li><a href="CBORDecoder.html">CBORDecoder</a></li><li><a href="CBOREncoder.html">CBOREncoder</a></li><li><a href="Channel.html">Channel</a></li><li><a href="ClientGamesUI.html">ClientGamesUI</a></li><li><a href="ClientGameUI.html">ClientGameUI</a></li><li><a href="Compressor.html">Compressor</a></li><li><a href="Configurator.html">Configurator</a></li><li><a href="Dialog.html">Dialog</a></li><li><a href="Dictionary.html">Dictionary</a></li><li><a href="Edition.html">Edition</a></li><li><a href="Explorer.html">Explorer</a></li><li><a href="FileDatabase.html">FileDatabase</a></li><li><a href="Fridge.html">Fridge</a></li><li><a href="Game.html">Game</a></li><li><a href="GameDialog.html">GameDialog</a></li><li><a href="GameSetupDialog.html">GameSetupDialog</a></li><li><a href="InvitePlayersDialog.html">InvitePlayersDialog</a></li><li><a href="JSAnalyser.html">JSAnalyser</a></li><li><a href="LetterBag.html">LetterBag</a></li><li><a href="LetterNode.html">LetterNode</a></li><li><a href="LoginDialog.html">LoginDialog</a></li><li><a href="Move.html">Move</a></li><li><a href="Player.html">Player</a></li><li><a href="Rack.html">Rack</a></li><li><a href="Server.html">Server</a></li><li><a href="ServerPlatform.html">ServerPlatform</a></li><li><a href="Square.html">Square</a></li><li><a href="StandaloneGamesUI.html">StandaloneGamesUI</a></li><li><a href="StandaloneGameUI.html">StandaloneGameUI</a></li><li><a href="Surface.html">Surface</a></li><li><a href="Tagger.html">Tagger</a></li><li><a href="Tile.html">Tile</a></li><li><a href="Trie.html">Trie</a></li><li><a href="TrieNode.html">TrieNode</a></li><li><a href="Turn.html">Turn</a></li><li><a href="UI.html">UI</a></li><li><a href="UserManager.html">UserManager</a></li><li><a href="XanadoPass.html">XanadoPass</a></li></ul><h3>Interfaces</h3><ul><li><a href="CBORTagger.html">CBORTagger</a></li><li><a href="Database.html">Database</a></li><li><a href="Platform.html">Platform</a></li></ul><h3>Mixins</h3><ul><li><a href="browser_GamesUIMixin.html">browser/GamesUIMixin</a></li><li><a href="browser_GameUIMixin.html">browser/GameUIMixin</a></li><li><a href="browser_SquareMixin.html">browser/SquareMixin</a></li><li><a href="browser_SurfaceMixin.html">browser/SurfaceMixin</a></li><li><a href="client_ClientUIMixin.html">client/ClientUIMixin</a></li><li><a href="client_PasswordMixin.html">client/PasswordMixin</a></li><li><a href="game_Commands.html">game/Commands</a></li><li><a href="game_Replay.html">game/Replay</a></li><li><a href="game_Undo.html">game/Undo</a></li><li><a href="standalone_StandaloneUIMixin.html">standalone/StandaloneUIMixin</a></li></ul><h3>Global</h3><ul><li><a href="global.html#backend/findBestPlay">backend/findBestPlay</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.7</a> on Sun Dec 04 2022 17:54:53 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
