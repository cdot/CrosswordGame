<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: build/JSAnalyser.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: build/JSAnalyser.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*@preserve Copyright (C) 2022 Crawford Currie http://c-dot.co.uk license MIT*/
/* eslint-env node */

const Path = require("path");
const assert = require("assert");
const uglify = require("uglify-js");

const { JSDOM } = require('jsdom');
const { window } = new JSDOM('&lt;!doctype html>&lt;html>&lt;body>&lt;/body>&lt;/html>');
global.window = window;
global.document = window.document;
global.navigator = { userAgent: "node.js" };
const jQuery = require('jquery');
global.jQuery = jQuery;
global.$ = jQuery;

/**
 * Analyse dependencies and generate packaed and compressed JS.
 */
class JSAnalyser {

  /**
   * Map of modules that have been studied so far.
   * @member {object.&lt;string,boolean>}
   */
  studied = {};

  /**
   * Map from requirejs module name to a physical path.
   * @member {object.&lt;string,string>}
   */
  modules = {};

  /**
   * Map from requirejs module name to a list of
   * requirejs module names that it depends on.
   * @member {object.&lt;string,Array>}
   */
  depends_on = {};

  constructor(config) {
    this.config = config;
  }

  /**
   * Add a dependency between two modules
   * @param {string} path the dependant (requirejs path)
   * @param {string} the dependee (requirejs path)
   */
  addDependency(path, on) {
    if (!this.depends_on[path])
      this.depends_on[path] = [];

    if (this.depends_on[path].indexOf(on) &lt; 0) {
      this.depends_on[path].push(on);
      console.debug(path, "depends on", on);
    }
  }

  /**
   * Study the requirejs shim config for the module, adding dependencies
   *  so uncovered.
   * @param {string} path the module (requirejs path)
   * @return {Promise} promise that resolves to undefined when the
   * shim has been studied.
   */
  studyShim(path) {
    //console.debug("Study shim", path);
    if (this.config.shim &amp;&amp; this.config.shim[path]) {
      const shim = this.config.shim[path];
      if (Array.isArray(shim)) {
        return Promise.all(shim.map(m => {
          this.addDependency(path, m);
          return this.studyModule(m);
        }));
      }
      else if (typeof shim === "object") {
        if (shim.deps &amp;&amp; Array.isArray(shim.deps)) {
          return Promise.all(shim.deps.map(m => {
            this.addDependency(path, m);
            return this.studyModule(m);
          }));
        }
      }
    }
    return Promise.resolve();
  }

  /**
   * Study a file of JS code, adding dependencies
   * so uncovered.
   * @param {string} js_path the module (physical file path)
   * @param {string} mod_id module identifier (unexpanded path)
   * @return {Promise} promise that resolves to undefined when the
   * JS has been studied.
   */
  studyJS(js_path, mod_id) {
    return this.config.readFile(this.config.resolvePath(js_path))
    .then(buffer => {
      const mod = {
        module: mod_id, path: js_path
      };
      this.modules[mod_id] = mod;

      const js = buffer.toString();
      const extras = [];

      // dialogs
      const dre = /\WDialog\s*\.\s*open\(\s*(["'])(.*?)\1/g;
      let m;
      while ((m = dre.exec(js)))
        this.addDependency(mod_id, m[2]);

      // requirejs calls.
      const qre = /\Wrequirejs\s*\(\s*\[\s*(.*?)\s*\]/g;
      while ((m = qre.exec(js))) {
        m[1].split(/\s*,\s*/)
        // We can only analyse dependencies for simple strings
        .filter(d => /^(['"]).*\1/.test(d))
        .map(mod => mod.replace(/^(["'])(.*?)\1/, "$2"))
        .forEach(mod => {
          if (/\s/.test(mod))
          // Add a dependency to the root to ensure the requirejs'ed
          // module gets loaded.
          this.addDependency("root", mod);
          extras.push(mod);
        });
      }

      const define = (deps, code) => {
        mod.hasDefine = true;
        if (Array.isArray(deps))
          deps.forEach(d => this.addDependency(mod_id, d));
      };
      define.amd = true;
      const requirejs = define;
      requirejs.config = () => {};
      const require = m => {
        console.error(`Unexpected require("${m}") in ${js_path} cannot be resolved`);
      };
      try {
        const module = {};
        eval(js);
        if (module.exports) {
          // commonJS module
          console.debug("COMMONJS", mod_id);
        }
      } catch (e) {
        e.stack = e.stack.replace(/&lt;anonymous>/g, js_path);
        console.error(e);
      }
      //console.debug(`Studied ${js_path} for ${module}`);
      if (!this.depends_on[mod_id])
        this.depends_on[mod_id] = [];
      return Promise.all(extras.map(d => this.studyModule(d)))
      .then(() => this.depends_on[mod_id]);
    })
    .then(deps => Promise.all(deps.map(d => this.studyModule(d))))
    .catch(e => {
      console.error(`Unable to analyse "${mod_id}" ${js_path} ${e.message}`);
    });
  }

  /**
   * Study a module, adding dependencies
   * so uncovered.
   * @param {string} path the module (requirejs path)
   * @return {Promise} promise that resolves to undefined when the
   * JS has been studied.
   */
  studyModule(path) {
    if (this.studied[path])
      return Promise.resolve();
    this.studied[path] = true;
    const shim = this.studyShim(path);
    const js_path = this.config.resolveJSPath(path);
    if (!js_path) {
      console.error(`No JS path for ${path}`);
      return Promise.resolve();
    }
    return this.studyJS(js_path, path);
  }

	/**
   * Compute a partial ordering of modules for loading. Only pass
   * the root key, other params are internal.
   * @param {string} key module name to explore
   * @param {string[]?} array containing the computed ordering
   * @param {object&lt;string,boolean>} visited record of modules visited
   */
	partialOrder(key, stack, visited) {
		if (!stack) stack = [];
		if (!visited) visited = {};
		visited[key] = true;
    if (this.depends_on[key])
		  for (const mod of this.depends_on[key]) {
			  if (!visited[mod])
				  this.partialOrder(mod, stack, visited);
		  }
		stack.push(key);
		return stack;
	}

  /**
   * Compute dependencies and report a module loading order.
   * @param {string} requirejs path to the root module (main program)
   * @return {Promise} promise resolving to an ordered list of paths
   * of contributing JS files
   */
  analyse(root) {
    return this.studyJS(root, "root")
    .then(() => this.partialOrder("root")
          .map(k => this.modules[k])
          .filter(m => m));
  }

  /**
   * Analyse the code and copy referenced modules
   * @param {string} infile root file to start analysis from. Path
   * relative to cfg.inBase.
   * @param {object} options control options
   * @param {boolean?} options.debug turn on debug
   * @param {boolean?} options.nopack disable packing
   * @param {boolean?} options.nocompress disable uglification
   * @param {string} options.config where to get requirejs.config from. Defaults
   * to reading it from the root.
   * @param {string?} options.base (directory) base of all URLs in the config
   * @return {string} the compressed code
   */
  copy(infile, options) {
    console.debug("Packing", infile);
    return this.analyse(infile)
    .then(mods => {
      console.debug("Analysis of",infile,"complete, copying");
      return Promise.all(
        mods.map(mod => {
          const path = this.config.resolvePath(mod.path);
          return this.config.copyFile(path);
        }));
    });
  }

  /**
   * Analyse the code and pack it into a single JS file.
   * @param {string} infile root file to start analysis from. Path
   * relative to cfg.inBase.
   * @param {object} options control options
   * @param {boolean?} options.debug turn on debug
   * @param {boolean?} options.nopack disable packing
   * @param {boolean?} options.nocompress disable uglification
   * @param {string} options.config where to get requirejs.config from. Defaults
   * to reading it from the root.
   * @param {string?} options.base (directory) base of all URLs in the config
   * @return {string} the compressed code
   */
  pack(infile, options) {
    console.debug("Compressing", infile);
    return this.analyse(infile)
    .then(mods => {
      console.debug("Analysis of",infile,"complete, combining");
      return Promise.all(
        mods.map(mod => this.config.readFile(this.config.resolvePath(mod.path))
                 .then(b => `_define_module("${mod.module}", () => {\n${b.toString()};\n});`)));
    })
    .then(js => js.join("\n\n"))
    .then(code => this.config.readFile("js/build/combined.js")
          .then(header => {
            console.debug("Combination of", infile, "built, uglifying");
            return `const _inBase = "${Path.normalize(this.config.inBase + "/..")}/";\n`
            + `const _outBase = "../";`
            + header + code;
          }))
    .then(code => {
      if (options.nocompress)
        return code;

      const res = uglify.minify(code, {
        compress: {},
        mangle: false,
        keep_fargs: true,
        keep_fnames: true,
        warnings: options.debug
      });
      if (res.warnings)
        console.warn(res.warnings);

      return res.code;
    });
  }
}
module.exports = JSAnalyser;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="BackendGame.html">BackendGame</a></li><li><a href="Board.html">Board</a></li><li><a href="BrowserBoard.html">BrowserBoard</a></li><li><a href="BrowserDatabase.html">BrowserDatabase</a></li><li><a href="BrowserGame.html">BrowserGame</a></li><li><a href="BrowserPlatform.html">BrowserPlatform</a></li><li><a href="BrowserPlayer.html">BrowserPlayer</a></li><li><a href="BrowserRack.html">BrowserRack</a></li><li><a href="BrowserTile.html">BrowserTile</a></li><li><a href="Channel.html">Channel</a></li><li><a href="ClientGamesUI.html">ClientGamesUI</a></li><li><a href="ClientGameUI.html">ClientGameUI</a></li><li><a href="Compressor.html">Compressor</a></li><li><a href="Configurator.html">Configurator</a></li><li><a href="Dialog.html">Dialog</a></li><li><a href="Dictionary.html">Dictionary</a></li><li><a href="Edition.html">Edition</a></li><li><a href="Explorer.html">Explorer</a></li><li><a href="FileDatabase.html">FileDatabase</a></li><li><a href="Fridge.html">Fridge</a></li><li><a href="Game.html">Game</a></li><li><a href="GameDialog.html">GameDialog</a></li><li><a href="GameSetupDialog.html">GameSetupDialog</a></li><li><a href="InvitePlayersDialog.html">InvitePlayersDialog</a></li><li><a href="JSAnalyser.html">JSAnalyser</a></li><li><a href="LetterBag.html">LetterBag</a></li><li><a href="LetterNode.html">LetterNode</a></li><li><a href="LoginDialog.html">LoginDialog</a></li><li><a href="Move.html">Move</a></li><li><a href="Player.html">Player</a></li><li><a href="Rack.html">Rack</a></li><li><a href="Server.html">Server</a></li><li><a href="ServerPlatform.html">ServerPlatform</a></li><li><a href="Square.html">Square</a></li><li><a href="StandaloneGamesUI.html">StandaloneGamesUI</a></li><li><a href="StandaloneGameUI.html">StandaloneGameUI</a></li><li><a href="Surface.html">Surface</a></li><li><a href="Tile.html">Tile</a></li><li><a href="Trie.html">Trie</a></li><li><a href="TrieNode.html">TrieNode</a></li><li><a href="Turn.html">Turn</a></li><li><a href="UI.html">UI</a></li><li><a href="UserManager.html">UserManager</a></li><li><a href="XanadoPass.html">XanadoPass</a></li></ul><h3>Interfaces</h3><ul><li><a href="Database.html">Database</a></li><li><a href="Platform.html">Platform</a></li></ul><h3>Mixins</h3><ul><li><a href="browser_GamesUIMixin.html">browser/GamesUIMixin</a></li><li><a href="browser_GameUIMixin.html">browser/GameUIMixin</a></li><li><a href="browser_SquareMixin.html">browser/SquareMixin</a></li><li><a href="browser_SurfaceMixin.html">browser/SurfaceMixin</a></li><li><a href="client_ClientUIMixin.html">client/ClientUIMixin</a></li><li><a href="client_PasswordMixin.html">client/PasswordMixin</a></li><li><a href="game_Commands.html">game/Commands</a></li><li><a href="game_Replay.html">game/Replay</a></li><li><a href="game_Undo.html">game/Undo</a></li><li><a href="standalone_StandaloneUIMixin.html">standalone/StandaloneUIMixin</a></li></ul><h3>Global</h3><ul><li><a href="global.html#backend/findBestPlay">backend/findBestPlay</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.7</a> on Tue Nov 29 2022 17:32:07 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
