/* eslint-env browser,node */
/* global APP_DIR */

/**
 * Dictionary support using a Directed Acyclic Word Graph (DAWG) in the
 * format generated by DAWG_Compressor.c
 * 
 * Note that the DAWG uses letter indices, and not actual characters, to
 * represent code points. To use this dictionary you also need an
 * alphabet of code points sorted in the same order as that used to
 * generate the DAWG.
 */
define("game/Dictionary", ["fs-extra"], (Fs) => {
	
	// Constants used in interpreting the DAWG
	const LETTER_BIT_SHIFT = 25;
	const LETTER_BIT_MASK      = 0x3E000000;
	const CHILD_INDEX_BIT_MASK = 0x1FFFFFF;
	const END_OF_WORD_BIT_MASK = 0x80000000;
	const END_OF_LIST_BIT_MASK = 0x40000000;
	
	const DAWG_OFFSET = 4; // 4 bytes initial data at top of file, stores the number of nodes in the DAWG
	const DAWG_ROOT = 1; // offset of the root node of the DAWG
	
	// Cache of dictionaries
	const dictionaries = {};

	class Dictionary {

		/**
		 * Promise to load a dictionary
		 */
		static async load(name) {
			if (dictionaries[name])
				return Promise.resolve(dictionaries[name]);
			
			return Fs.readFile(`${APP_DIR}/dictionaries/${name}.dict`)
			.then(dawg => {
				console.log(`Loaded dictionary ${name}`);
				dictionaries[name] = new Dictionary(dawg);
				return dictionaries[name];
			});
		}
		
		/**
		 * @param dawg a Buffer or Array containing the DAWG data.
		 * It's actually an array of little-endian 4-byte integers.
		 */
		constructor(dawg) {
			this.dawg = dawg;

			let numberOfNodes = this.readNumber(0);
			console.log(`${dawg.length} bytes ${numberOfNodes} nodes`);
		}

		sNode(i) {
			return `${i}: ${this.DAWG_Letter(i)} ${this.DAWG_IsEndOfWord(i)} ${this.DAWG_NextIndex(i)} ${this.DAWG_ChildIndex(i)}`;
		}

		/**
		 * Apply the callback to each of the words represented in the DAWG (potentially huge!)
		 * @param callback function that accepts an array of letter indices
		 */
		walk(callback) {
			return this.DAWG_walk(DAWG_ROOT, [], callback);
		}
		
		// @private
		DAWG_walk(dawg_index, s, cb) {
			const letter = this.DAWG_Letter(dawg_index);

			let currentString = s.slice(0, s.length);
			currentString.push(letter);

			if (this.DAWG_IsEndOfWord(dawg_index))
				cb(currentString);
			
			const childIndex = this.DAWG_ChildIndex(dawg_index);
			if (childIndex > 0) {
				//console.log(`----DAWG_ChildIndex ${childIndex}`);
				this.DAWG_walk(childIndex, currentString, cb);
			}
			
			const nextIndex = this.DAWG_NextIndex(dawg_index);
			//alert("DAWG_NextIndex: " + nextIndex);
			if (nextIndex > 0) {
				//console.log(`---DAWG_NextIndex ${nextIndex}`);
				this.DAWG_walk(nextIndex, s, cb);
			}
		}
		
		// @private Read a 4-byte little-endian unsigned integer
		// from the DAWG data at the given byte index
		readNumber(byte_offset) {
			let result = 0;
			for (let i = byte_offset + 3; i >= byte_offset; i--) {
				result = (result << 8) | this.dawg[i];
			}

			return result;
		}

		// @private read a 4-byte little-endian number at the given
		// (1-based) int offset
		DAWG_Number(offset) {
			let byte_offset = 4 * offset;// + DAWG_OFFSET;
			let result = 0;
			for (let i = byte_offset + 3; i >= byte_offset; i--) {
				result = (result << 8) | this.dawg[i];
			}
			return result;
		}

		// Get the index of the letter encoded in word at the given index
		// @private
		DAWG_Letter(offset) {
			return (this.DAWG_Number(offset) & LETTER_BIT_MASK) >> LETTER_BIT_SHIFT;
		}

		// Determine if the word at the given index is the end of a word
		// @private
		DAWG_IsEndOfWord(offset) {
			return (this.DAWG_Number(offset) & END_OF_WORD_BIT_MASK) != 0;
		}

		// Get the next index in a list, or 0 if this is the end of a list
		// @private
		DAWG_NextIndex(offset) {
			const val = this.DAWG_Number(offset) & END_OF_LIST_BIT_MASK;
			return val == 0 ? (offset + 1) : 0;
		}

		// Get the index of a child node at this offset
		// @private
		DAWG_ChildIndex(offset) {
			return this.DAWG_Number(offset) & CHILD_INDEX_BIT_MASK;
		}

		// @private
		checkWordRecursive(chars, chars_index, dawg_index) {
			if (this.DAWG_Letter(dawg_index) == chars[chars_index]) {
				if (chars_index == chars.length - 1)
					return this.DAWG_IsEndOfWord(dawg_index);
				const childIndex = this.DAWG_ChildIndex(dawg_index);
				if (childIndex > 0)
					return this.checkWordRecursive(
						chars, chars_index + 1, childIndex);
				return false;
			} else {
				// Try the next alternative
				const nextIndex = this.DAWG_NextIndex(dawg_index);
				if (nextIndex > 0)
					return this.checkWordRecursive(chars, chars_index, nextIndex);
				return false;
			}
		}

		/**
		 * Check if a word is in the dictionary
		 * @param chars a word to check, as an array of letter indices
		 * @return true if the word is found, false otherwise
		 */
		hasWord(chars) {
			return this.checkWordRecursive(chars, 0, DAWG_ROOT);
		}

		// @param dawg_index offset of the current DAWG node
		// @param s the string built so far in this recursion
		// @param sortedChars the available set of characters, sorted
		// @private
		findAnagramsRecursive(dawg_index, s, sortedChars) {
			let foundWords = [];

			//console.log("far", this.sNode(dawg_index), s);
			
			s.push(this.DAWG_Letter(dawg_index));

			if (this.DAWG_IsEndOfWord(dawg_index))
				// A word is found
				foundWords.push(s.slice(0, s.length));

			let childIndex = this.DAWG_ChildIndex(dawg_index);
			let previousChar = -1;
			if (sortedChars.length > 0 && childIndex > 0) {
				// Characters left, and this node has children
				for (let i = 0; i < sortedChars.length; i++) {
					const currentChar = sortedChars[i];
					
					if (currentChar == previousChar)
						continue; // hmmmmm
					
					do { // for each child of the subnode
						const letter = this.DAWG_Letter(childIndex);
						if (currentChar == letter) {
							sortedChars.splice(i, 1);
							const moreWords = this.findAnagramsRecursive(
								childIndex, s, sortedChars);
							foundWords = foundWords.concat(moreWords);
							sortedChars.splice(i, 0, currentChar);
							childIndex = this.DAWG_NextIndex(childIndex);
							break;
						}

						if (currentChar < letter)
							// Because we sorted the characters before
							// starting, we know that any lower character
							// has already been considered
							break;

						// Next child
						childIndex = this.DAWG_NextIndex(childIndex);
						
					} while (childIndex > 0);
					
					if (childIndex <= 0) break;
					
					previousChar = currentChar;
				}
			}
			
			s.pop();
			
			return foundWords;
		}

		/**
		 * Find anagrams of a set of letter indexes
		 * @param theChars array of letter indices
		 * @return an array of anagrams, each of which is a word from
		 * the dictionary as a letter-index array
		 */
		findAnagrams(theChars) {	
			if (theChars.length < 2)
				return [ theChars ];

			// Sort the list of characters. This is to avoid
			// unneccesary recursions in findAnagramsRecursive by
			// eliminating already-considered letters from consideration.
			let sortedChars = theChars.slice(0, theChars.length);
			sortedChars.sort();
			
			let foundWords = [];
			let previousChar = -1; // Impossible
			
			for (let i = 0; i < sortedChars.length; i++) {
				const currentChar = sortedChars[i];		

				if (currentChar == previousChar)
					continue; // no point doing it again

				// Remove currentChar from the list
				sortedChars.splice(i, 1);

				// Recursively find anagrams rooted at the current index
				// using the remaining letters
				const moreWords = this.findAnagramsRecursive(
					DAWG_ROOT + currentChar, [], sortedChars);
				
				// Put the letter back where we found it
				sortedChars.splice(i, 0, currentChar);

				if (moreWords.length > 0)
					foundWords = foundWords.concat(moreWords);

				previousChar = currentChar;
			}
			
			return foundWords;
		}
	}
	return Dictionary;
});
