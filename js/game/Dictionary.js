/* See README.md at the root of this distribution for copyright and
   license information */
/* eslint-env amd, node */

/* global APP_DIR */
/* global DataView */

/**
 * Dictionary support using a Directed Acyclic Word Graph (DAWG) in the
 * format generated by DAWG_Compressor.js
 * 
 * Note that the DAWG uses letter indices, and not actual characters, to
 * represent code points. To use this dictionary you also need an
 * alphabet of code points sorted in the same order as that used to
 * generate the DAWG.
 *
 * Note also the use of fs-extra and node-gzip makes this server-side only.
 */
define("game/Dictionary", ["fs-extra", "node-gzip"], (Fs, Gzip) => {
	
	// Constants used in interpreting the integer encoding of the DAWG
	const END_OF_WORD_BIT_MASK = 0x1;
	const END_OF_LIST_BIT_MASK = 0x2;
	const CHILD_INDEX_SHIFT = 2;
	const CHILD_INDEX_BIT_MASK = 0x3FFFFFFF;
	
	// Cache of dictionaries
	const dictionaries = {};

	// DAWG
	class Node {
		constructor(letter) {
			this.letter = letter;
			// The next 2 are numbers during loading, converted to a pointer
			this.next = null;
			this.child = null;
		}

		/**
		 * Enumerate each word in the dictionary. Calls cb on each word.
		 * Caution this is NOT the same as dawg/Tnode.eachWord.
		 * @param s the word constructed so far
		 * @param cb the callback, accepts a string and a node
		 */
		eachWord(s, cb) {
			if (this.isEndOfWord)
				cb(s + this.letter, this);
			
			if (this.child)
				this.child.eachWord(s + this.letter, cb);
			
			if (this.next)
				this.next.eachWord(s, cb);
		}

		/**
		 * Enumerate each node in the dictionary in depth-first order.
		 * Calls cb on each node.
		 * @param cb the callback, accepts a node. If the callback returns
		 * true, will carry on, otherwise will terminate the enumeration.
		 */
		eachNode(cb) {
			if (!cb(this))
				return false;
			
			if (this.child && !this.child.eachNode(cb))
				return false;
			
			if (this.next && !this.next.eachNode(cb))
				return false;

			return true;
		}

		/**
		 * Build forward and backward lists to allow us to navigate
		 * in both directions - forward through words, and backwards too.
		 */
		buildLists(pre) {
			this.pre = [];
			this.post = [];
			if (pre) {
				this.pre.push(pre);
				pre.post.push(this);
			}
			if (this.child)
				this.child.buildLists(this);
			if (this.next)
				this.next.buildLists(pre);
		}
		

		/**
		 * Return the Node that matches the last character
		 * in chars, even if it's not isEndOfWord
		 * @param chars a string of characters that may
		 * be the root of a word
		 * @param index the start index within partialWord
		 */
		match(chars, index) {
			if (typeof index === "undefined")
				index = 0;
			if (this.letter == chars[index]) {
				if (index == chars.length - 1)
					return this;
				if (this.child)
					return this.child.match(chars, index + 1);
				return null;
			} else {
				// Try the next alternative
				if (this.next)
					return this.next.match(chars, index);
				return null;
			}
		}
		
		/**
		 * Check if the word beyond index is represented by the
		 * DAWG below this node
		 * @param chars the word we're checking
		 * @param index the end of the substring matched to reach this node
		 */
		checkWord(chars, index) {
			let m = this.match(chars, index);
			return m && m.isEndOfWord;
		}

		/**
		 * @param realWord the string built so far in this recursion
		 * @param blankedWord the string built using spaces for blanks
		 * if they are used
		 * @param sortedChars the available set of characters, sorted
		 */
		findAnagrams(realWord, blankedWord, sortedChars, foundWords) {
			
			// is this character available from sortedChars?
			// Only use blank if no other choice
			let i = sortedChars.indexOf(this.letter);
			if (i < 0) // not there, try blank
				i = sortedChars.indexOf(' ');
			
			if (i >= 0) {
				const match = sortedChars[i];
				
				// The char is available from sortedChars.
				// Is this then a word?
				if (this.isEndOfWord) {
					// A word is found
					foundWords[realWord + this.letter] = blankedWord + match;
				}

				if (sortedChars.length == 1)
					return;
				
				// Cut the matched letter out of sortedChars and recurse
				// over our child node chain
				sortedChars.splice(i, 1);
			
				for (let child = this.child; child; child = child.next) {
					child.findAnagrams(
						realWord + this.letter,
						blankedWord + match,
						sortedChars,
						foundWords);
				}
				sortedChars.splice(i, 0, match);
			}
			
			if (this.next)
				this.next.findAnagrams(
					realWord, blankedWord, sortedChars, foundWords);

			return foundWords;
		}
	}
	
	class Dictionary {

		/**
		 * @param dawg a Buffer or Array containing the DAWG data.
		 * It's actually an array of little-endian 4-byte integers.
		 */
		constructor(name, data) {
			this.name = name;
			let dv = new DataView(data);
			let index = 0;
			let numberOfNodes = dv.getUint32(4 * index++);
			let nodes = [];
			for (let i = 0; i < numberOfNodes; i++) {
				let letter = dv.getUint32(4 * index++);
				let node = new Node(String.fromCodePoint(letter));
				let numb = dv.getUint32(4 * index++);
				if ((numb & END_OF_WORD_BIT_MASK) != 0)
					node.isEndOfWord = true;
				if ((numb & END_OF_LIST_BIT_MASK) == 0)
					node.next = i + 1;
				if (((numb >> CHILD_INDEX_SHIFT) & CHILD_INDEX_BIT_MASK) > 0)
					node.child = ((numb >> CHILD_INDEX_SHIFT) & CHILD_INDEX_BIT_MASK);
				//console.log(`${nodes.length} `,node);
				nodes.push(node);
			}
			// Convert node indices to pointers
			for (let i = 0; i < nodes.length; i++) {
				let node = nodes[i];
				if (typeof node.next === "number")
					node.next = nodes[node.next];
				if (typeof node.child === "number")
					node.child = nodes[node.child];
			}
			this.root = nodes[0];
			// Build forward and back lists
			this.root.buildLists();
			// Sequence index will be created on demand
			this.sequenceRoots = null;
		}

		/**
		 * Promise to load a dictionary
		 */
		static async load(name) {
			if (dictionaries[name])
				return Promise.resolve(dictionaries[name]);
			
			return Fs.readFile(`${APP_DIR}/dictionaries/${name}.dict`)
			.then(data => Gzip.ungzip(data))
			.then(buffer => {
				dictionaries[name] = new Dictionary(name, buffer.buffer);
				console.log(`Loaded dictionary ${name}`);
				return dictionaries[name];
			});
		}

		/**
		 * Apply the callback to each of the words represented in the DAWG
		 * (potentially huge!)
		 * @param callback function that accepts a string and a terminal node
		 */
		eachWord(callback) {
			return this.root.eachWord('', callback);
		}

		/**
		 * Return the Node that matches the last character
		 * in chars, starting from the root
		 * @param chars a string of characters that may
		 * be the root of a word
		 */
		match(chars) {
			return this.root.match(chars, 0);
		}
		
		/**
		 * Check if a word is in the dictionary
		 * @param chars a word to check
		 * @return true if the word is found, false otherwise
		 */
		hasWord(chars) {
			return this.root.checkWord(chars, 0) !== null;
		}

		/**
		 * Find anagrams of a set of letters
		 * @param theChars the letters
		 * @return a map of anagrams to the letter sequence that matched
		 */
		findAnagrams(theChars) {
			theChars = theChars.toUpperCase();
			
			if (theChars.length < 2)
				return [ theChars ];

			// Sort the list of characters. Not strictly needed,
			// just easier to debug.
			let sortedChars = theChars.split("").sort();

			//console.log("Sorted chars", sortedChars);
			const foundWords = {};
			this.root.findAnagrams('', '', sortedChars, foundWords)
			return foundWords;
		}

		/**
		 * For each letter of the alphabet, establish a list of valid
		 * start points, such that at least one start point must match()
		 * for any sequence of chars, or there can't possibly be a word.
		 */
		createSequenceRoots() {
			this.sequenceRoots = {};
			this.root.eachNode(node => {
				if (!this.sequenceRoots[node.letter])
					this.sequenceRoots[node.letter] = [node];
				else
					this.sequenceRoots[node.letter].push(node);
				return true;
			});
			console.log(`Created sequence roots for dictionary '${this.name}'`);
		}

		sequenceRoots(ch) {
			if (!this.sequenceRoots)
				this.createSequenceRoots();
			return this.sequenceRoots[ch];
		}
		
		/**
		 * Find start node for the character sequence
		 * in the sequence index i.e. it forms a valid sub-part of a word
		 * in the dictionary. This way we can quickly eliminate sequences
		 * such as 'QX' which are never found in the dictionary. Note that
		 * we don't have any way to reproduce the words that the sequence
		 * is a valid part of; that's not the point, this is intended to help
		 * eliminate invalid sequences when extending a word backwards from
		 * a seed letter.
		 */
		findSequence(seq) {
			if (!this.sequenceRoots)
				this.createSequenceRoots();
			const roots = this.sequenceRoots[seq[0]];
			if (!roots || roots.length == 0) {
				console.log(`'${seq[0]}' has no roots`);
				return false;
			}
			for (let root of roots) {
				if (root.match(seq, 0))
					return root;
			}
			// Not found
			return null;
		}

		/**
		 * Return true if a start node for the character sequence is found
		 * in the sequence index i.e. it forms a valid sub-part of a word
		 * in the dictionary. This way we can quickly eliminate sequences
		 * such as 'QX' which are never found in the dictionary. Note that
		 * we don't have any way to reproduce the words that the sequence
		 * is a valid part of; that's not the point, this is intended to help
		 * eliminate invalid sequences when extending a word backwards from
		 * a seed letter.
		 */
		hasSequence(seq) {
			return this.findSequence(seq) != null;
		}
	}
	return Dictionary;
});
