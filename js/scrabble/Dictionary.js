/* eslint-env browser,node */

/**
 * Dictionary support using a Directed Acyclic Word Graph (DAWG) in the format generated by DAWG_Compressor.c
 */
define("scrabble/Dictionary", () => {
	
	// Constants used in interpreting the DAWG
	const LETTER_BIT_SHIFT = 25;
	const LETTER_BIT_MASK      = 0x3E000000;
	const CHILD_INDEX_BIT_MASK = 0x1FFFFFF;
	const END_OF_WORD_BIT_MASK = 0x80000000;
	const END_OF_LIST_BIT_MASK = 0x40000000;
	
	const DAWG_OFFSET = 4; // 4 bytes initial data at top of file, stores the number of nodes in the DAWG

	class Dictionary {

		/**
		 * @param data a Buffer or Array containing the DAWG data. It's actually an array
		 * of little-endian 4-byte integers.
		 * @param maxWordLength longest word possible
		 * @param alphabet index for DAWG bytes -> characters e.g. "ABCDEFGH...XYZ"
		 */
		constructor(data, maxWordLength, alphabet) {
			this.alphabet = alphabet;
			this.maxWordLength = maxWordLength;
			this.data = data;
			
			//let numberOfNodes = this.readNumber();
			//console.log(`${data.length} bytes ${numberOfNodes} nodes`);
		}

		/**
		 * Apply the callback to each of the words represented in the DAWG (potentially huge!)
		 * @param callback function that accepts a word
		 */
		walk(callback) {
			return this.DAWG_walk(1, "", callback);
		}
		
		// @private
		// dawg_index is 1-based
		DAWG_walk(dawg_index, s, cb) {
			const letter = this.DAWG_Letter(dawg_index);
			
			if (this.DAWG_IsEndOfWord(dawg_index))
				cb(s + letter);
			
			const childIndex = this.DAWG_ChildIndex(dawg_index);
			if (childIndex > 0) {
				//console.log(`----DAWG_ChildIndex ${childIndex}`);
				this.DAWG_walk(childIndex, s + letter, cb);
			}
			
			const nextIndex = this.DAWG_NextIndex(dawg_index);
			//alert("DAWG_NextIndex: " + nextIndex);
			if (nextIndex > 0) {
				//console.log(`---DAWG_NextIndex ${nextIndex}`);
				this.DAWG_walk(nextIndex, s, cb);
			}
		}
		
		// @private Read a 4-byte little-endian unsigned integer from the DAWG data
		// at the given byte index
		readNumber(iFrom) {
			let result = 0;
			for (let i = iFrom + 3; i >= iFrom; i--) {
				result = (result << 8) | this.data[i];
			}

			return result;
		}

		// @private read a 4-byte little-endian number at the given data index
		numberAt(word) {
			let iFrom = 4 * word + DAWG_OFFSET;
			let result = 0;
			for (let i = iFrom + 3; i >= iFrom; i--) {
				result = (result << 8) | this.data[i];
			}
			return result;
		}

		// Get the letter encoded in word at the given index
		// @private
		DAWG_Letter(word) {
			const alphabetPos = (this.numberAt(word) & LETTER_BIT_MASK) >> LETTER_BIT_SHIFT;
			return this.alphabet.charAt(alphabetPos);
		}

		// Determine if the word at the given index is the end of a word
		// @private
		DAWG_IsEndOfWord(word) {
			return (this.numberAt(word) & END_OF_WORD_BIT_MASK) != 0;
		}

		// Get the next index in a list, or 0 if this is the end of a list
		// @private
		DAWG_NextIndex(word) {
			const val = this.numberAt(word) & END_OF_LIST_BIT_MASK;
			return val == 0 ? (word + 1) : 0;
		}

		// Get the index of a child node at this word
		// @private
		DAWG_ChildIndex(word) {
			return this.numberAt(word) & CHILD_INDEX_BIT_MASK;
		}

		// @private
		// dawg_index is 1-based
		checkWordRecursive(theWord, string_index, dawg_index) {
			const ch = theWord[string_index];
			const letter = this.DAWG_Letter(dawg_index);
			if (letter == ch) {
				if (string_index == (theWord.length - 1)) {
					return this.DAWG_IsEndOfWord(dawg_index);
				} else {
					const childIndex = this.DAWG_ChildIndex(dawg_index);
					if (childIndex > 0)
						return this.checkWordRecursive(theWord, string_index+1, childIndex);
					else
						return false;
				}
			} else {
				const nextIndex = this.DAWG_NextIndex(dawg_index);
				if (nextIndex > 0)
					return this.checkWordRecursive(theWord, string_index, nextIndex);
				else
					return false;
			}
		}

		/**
		 * Check if a word is in the dictionary
		 * @param theWord word to check
		 * @return true if the word is found, false otherwise
		 */
		checkWord(theWord) {
			theWord = theWord.toUpperCase();
			return this.checkWordRecursive(theWord, 0, 1); //dawg_index is NOT zero-based (start with 1)
		}

		// @private
		findAnagramsRecursive(dawg_index, currentString, sortedChars) {
			//dawg_index is NOT zero-based (start with 1)
			let retArray = [];
			
			let previousChar = 0;
			let tempIndex = this.DAWG_ChildIndex(dawg_index);
			
			currentString += this.DAWG_Letter(dawg_index);

			if (this.DAWG_IsEndOfWord(dawg_index)) {
				retArray.push(currentString);
			}

			if ((sortedChars.length > 0) && (tempIndex > 0)) {
				for (let i = 0; i < sortedChars.length; i++) {
					const currentChar = sortedChars[i];
					if (currentChar == previousChar)
						continue;
					
					do {
						const tempLetter = this.DAWG_Letter(tempIndex);
						if (currentChar == tempLetter) {
							sortedChars.splice(i, 1);
							const retAr = this.findAnagramsRecursive(tempIndex, currentString, sortedChars);
							retArray = retArray.concat(retAr);
							sortedChars.splice(i, 0, currentChar);
							
							tempIndex = this.DAWG_NextIndex(tempIndex);
							break;
						} else {
							const alphabetPos1 = this.alphabet.indexOf(currentChar);
							const alphabetPos2 = this.alphabet.indexOf(tempLetter);
							
							if (alphabetPos1 < alphabetPos2) break;
						}
						
						tempIndex = this.DAWG_NextIndex(tempIndex);
						
					} while (tempIndex > 0);
					
					if (tempIndex <= 0) break;
					
					previousChar = currentChar;
				}
			}
			
			return retArray;
		}

		/**
		 * Find anagrams of a set of letters
		 * @param theChars string containing the letters
		 * @return an array of anagrams, each of which is a word from the dictionary
		 */
		findAnagrams(theChars) {	
			theChars = theChars.toUpperCase();

			// Filter the string on legal characters, and sort it
			let sortedChars = [];
			for (let i = 0; i < theChars.length; i++) {
				const aChar = theChars[i];
				if (this.alphabet.indexOf(aChar) >= 0)
					sortedChars.push(aChar);
			}
			sortedChars.sort();
			
			let string = sortedChars.join("");	
			let anagrams = [];

			if (sortedChars.length < 2)
				return anagrams;

			const charBank = [];
			for (let i = 0; i < sortedChars.length; i++) {
				charBank.push(sortedChars[i]);
			}
			
			let previousChar = 0;
			
			for (let i = 0; i < charBank.length; i++) {
				const currentChar = charBank[i];
				
				if (currentChar == previousChar)
					continue;

				sortedChars.splice(i, 1);
				
				const dawg_index = this.alphabet.indexOf(currentChar) + 1;
				
				const retAr = this.findAnagramsRecursive(dawg_index, "", sortedChars);
				anagrams = anagrams.concat(retAr);
				
				sortedChars.splice(i, 0, currentChar);
				
				previousChar = currentChar;
			}
			
			return anagrams;
		}
	}
	return Dictionary;
});
